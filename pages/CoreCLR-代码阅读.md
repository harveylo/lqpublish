# [[C/C++代码阅读杂记]]
- # 目标
	- 探明为什么CoreCLR能作为可选项出现在菜单中
		- ``Editor\Mono\Inspector\PlayerSettingsEditor\PlayerSettingsEditor.cs``中的
		- ![image.png](../assets/image_1689670826054_0.png)
		- 而只要当前的``BuildTargetGroup``是``Standalone``，调用``Editor\Mono\Modules\PlatformSupportModule.cs``中的``GetScriptingImplementations``只要``IsSourceBuild``判断通过就会有``CoreCLR``选项可用
	- 探明为什么会显示**CoreCLR**未安装
		- 在特定目录中的``WindowsStandaloneSupport/Variations"目录下缺失了backend相关的目录
	- 探明UnityPlayer.dll是如何生成的，是否能够直接生成CoreCLR的UnityPlayer.dll
		- 在建造系统中可以直接建造``CoreCLR``版本的Player
		- 但是直接使用如此构建来的Player会出现**``Failed to load mono``**错误
			- ![image.png](../assets/image_1689820015021_0.png)
	- 尝试解决``Failed to load mono``错误
		- 直接将mono build的player的运行时移过来，则不会再产生此错误，但是仍然无法正常运行，会直接退出
	- 阅读build脚本，探明CoreCLR的UnityPlayer.dll文件是如何被打包生成的
	- 通过Debug，探明Player的行为
- # 疑问
	- ``BuildTargetPlatform``和``BuiltTargetPlatformGroup``是什么关系
	- 有一些枚举类型之间似乎是一一对应关系,不过有的是在托管代码中,有的是在CLR内部，如何绑定起来
		- 好像是用``BIND_MANAGED_TYPE_NAME``宏，如``BIND_MANAGED_TYPE_NAME(BuildTargetPlatform, UnityEditor_BuildTarget)``
- # Player Setting
	- 在player setting中看到有关于scripting backend的选项
	- ![image.png](../assets/image_1689149471059_0.png)
	- 通过搜索定位到处理此界面业务逻辑的文件``Editor\Mono\Inspector\PlayerSettingsEditor\PlayerSettingsEditor.cs``中
	- 其中关于Scripting Backend的处理代码：
	- ![image.png](../assets/image_1689150119406_0.png){:height 226, :width 671}
	- 检查``ScriptingImplementation``类型，发现其定义出现在文件``Editor\Mono\PlayerSettings.bindings.cs``
		- ![image.png](../assets/image_1689155716885_0.png)
- # 设置``ScriptingImplementation``为`CoreCLR`之后的行为
	- ``Editor\Mono\AssemblyHelper.cs``文件中``AssemlyHelper``类的``IgnoreAssembly``函数会对所有可能属于.NET或windows运行时的程序集返回true
	  ![image.png](../assets/image_1689228805772_0.png)
		- 做判断的``CouldBelongToDotnetOrWindowsRuntime``函数
		  ![image.png](../assets/image_1689228895490_0.png)
	- 在``Editor\Mono\BuildPipeline\DesktopStandaloneBuildWindowExtension.cs``文件的``DesktopStandaloneBuildWindowExtension``类的函数``GetCannotBuildPlayerInCurrentSetupError``会在``m_HasCoreCLRPlayers``为false时返回错误字符串
		- ![image.png](../assets/image_1689231607794_0.png)
		- ``Unsupported``类定义在``Editor\Mono\Unsupported.bindings.cs``文件中，其中声明了``IsSourceBuild``函数
			- ![image.png](../assets/image_1689233617496_0.png)
			- 此函数并不是``C#``写的，其定义在外部，实际是在文件``Editor\Src\EditorHelper.cpp``中定义
				- ![image.png](../assets/image_1689233966108_0.png)
				- [[$blue]]==**重点：理解这个函数的关键在于其调用的**==``GetBaseUnityDeveloperFolder``函数的行为
					- 此函数会直接调用``Runtime\Utilities\FileUtilities.cpp``中的``GetDeveloperWorkspaceRoot``
						- ![image.png](../assets/image_1689585015987_0.png)
					- 上一个函数又会调用``GetApplicationFolder``函数
						- 这个函数经过多个包装类和继承的转发，**在Windows平台下**最终调用的应该是``PlatformDependent\Win\LocalFileSystemWindowsShared.cpp``中的``GetApplicationFolder``函数
					- 上一个函数会调用同一个类中的``GetApplicationPath``函数
					- 最终会一路调用到``C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\libloaderapi.h``中的``GetModuleFileNameW``函数
						- 这个函数是Windows自带的库函数，此库和**模块(Module)加载**相关
					- 最终：``GetApplicationPath``拿到当前可执行文件的路径，``GetApplicationFolder``删除最后一个路径元素(即可执行文件的名称)，返回处理后的路径(即可执行文件所在的文件夹的路径)
					- ``GetDeveloperWorkspaceRoot``函数会在拿到可执行文件所在目录之后不停向父目录探索知道找到``.hg``或``build``目录
				- 拿到疑似项目目录的路径之后再去检查是否存在``Runtime``和``Editor``这两个目录，如果都存在，则认为是目前正在运行的Unity是从源码build而来的，这也是此函数名``IsSourceBuild``的含义
					- ``__FAKEABLE_FUNCTION__``是一个宏，定义在``Runtime\Testing\Fakeable.h``中
						- ![image.png](../assets/image_1689234834634_0.png)
						- 实际上就是啥都不做，一个空定义，可能在测试中有用
					- ``IsHumanControllingUs``函数定义在文件``Runtime\Utilities\Argv.cpp``
						- ![image.png](../assets/image_1689235666800_0.png)
						- ``knownArgs``定义在同一个文件中
							- ![image.png](../assets/image_1689235943168_0.png)
							  ![image.png](../assets/image_1689236315582_0.png)
							- 这个结构体是用来辅助处理命令行参数的，静态变量``knownArgs``在函数``SetupArgv``中被设置，此函数在各个平台的main函数(包括editor和player)中被调用**处理命令行参数**
						- 也就是说，判断目前是否有人在操作的条件就是启动时**不是batch模式，不是自动模式也不是测试模式**
					- ``core::string``是Unity自定义的字符串类型，定义在``Runtime\Core\Containers\String.h``
					- 如果如要检查是否是人在操作，那么在检查不通过时直接返回false
		- ``DesktopStandaloneBuildWindowExtension``类被多个类继承
			- ``PlatformDependent\WinPlayer\Extensions\Managed\WindowsStandaloneBuildWindowExtension.cs``中的``WindowsStandaloneBuildWindowExtension``类
				- 其在``PlatformDependent\WinPlayer\Extensions\Managed\ExtensionModule.cs``中被实例化一次
					- ![image.png](../assets/image_1689317718762_0.png){:height 59, :width 544}
					- ![image.png](../assets/image_1689317850055_0.png)
					- **能找到``GetPlayerbackEngineDirectory``函数，但是找不到``BuildPipeline``的定义**
						- 但是能找到``BuildPipline``的namespace
					- 调用这个函数时使用的参数分别是
						- ``BuildTarget``是一个枚举类型，定义在``Editor\Mono\BuildTarget.cs``中
							- 似乎和``Runtime\Serialize\BuildTarget.h``中的``BuildTargetPlatform``枚举类型是一一对应关系
							- ``StandaloneWindows``的值为5
								- ![image.png](../assets/image_1689648782477_0.png){:height 60, :width 309}
						- ``BuildOption``没有在源码中找到定义，但是在``Documentation\TrackedApi\editor\UnityEditor.api``能看到定义
							- ``None``的值是0
								- ![image.png](../assets/image_1689649261922_0.png)
					- 函数``GetPlaybackEngineDirectory``在``Editor\Src\BuildPipeline\BuildTargetPlatformSpecific.cpp``中
					  id:: 64b0f231-0fc4-4843-b861-f8bc2d30e173
						- 此函数有两个重载，其中一个接受三个参数，但是最后一个参数``assertUnsupportedPlatforms``在头文件定义中默认为``true``，因此可以不用给出
					- ``GetPlaybackEngineDirectory``只是简单地调用函数``GetPlaybackEngineExtensionDirectory``，此函数在同一个文件中，返回值应该是目录``build\WindowsStandaloneSupport``
						- 调用时补足了``buildTargetGroup``参数为``BuildTargetPlatformGroup``类型的``kPlatformUnknown``，值为0
							- ![image.png](../assets/image_1689649583115_0.png)
						- 且最后一个参数``overridemode``默认为``kUseOverride``
						- **[[$red]]==这个Resouce Build是什么意思？==，从行为来理解是在判断有没有某些命令行参数**，不知道这个resource的具体工程含义是什么
							- ![image.png](../assets/image_1689649781455_0.png){:height 53, :width 362}
						- ``playbackEngineName``经过函数查询，得到的结果应该是``"WindowsStandaloneSupport"``
							- 首先进入``GetBuildTargetName``函数，由于``buildTargetGroup``是``kPlatformUnknown``，进入``GetDirNameForBuildTarget``函数
							- ``GetDirNameForBuildTarget``函数是``BuildTargetDiscovery``类的一个函数，因此在调用此函数前需要通过``BuildTargetDiscovery``获取一个实例(应该也是全局唯一的实例，这个类感觉应该是个单例)。此实例获取函数同时也会检查预加载的平台信息是否已经初始化，如果没有的话会调用此类的``PreloadKnownBuildTargets``函数，此函数会预加载一系列的平台信息，这些信息会通过``AddDiscoveredTargetInfo``函数存放到类的成员变量``m_BuildTargetMap``中，例如目前我们所关心的windows standalone player的建造信息就包含如下信息：
								- ![image.png](../assets/image_1689663193597_0.png)
								- 注意到增添CoreCLR的时候做了一次``IsSourceBuild``判断，目前的源码中似乎只要是和CoreCLR的地方经常用到``IsSourceBuild``判断，因此猜测目前的CoreCLR选项只是一个placeholder，可能没有实际功能
							- ``GetDirNameBuildTarget``函数首先通过枚举参数``platform``查询得到``string``类型的key，``kBuildStandaloneWinPlayer``对应的key是``"win"``
							- 获取字符串key之后再调用同名函数通过key获取目录名称，即去``m_BuildTargetMap``中查询，然后返回``dirName``域
						- ``GetApplicationContentsPath``函数返回可执行文件目录下的``Data``文件夹的路径，在其后又append了一个``PlaybackEngines``目录名称
						- ``GetTargetBuildFolder``函数返回项目目录下``build``文件夹的路径
						- 相当于去上述两个路径下寻找是否存在``WindowsStandaloneSupport``目录，如果存在，则返回此目录路径
						- 如果都不存在，则去可执行文件目录下的``PlaybackEngines``目录下寻找，如果存在则返回路径，如果仍不存在，则输出一个错误信息
					- 在``build\WindowsStandaloneSupport\Variations``目录下依次寻找是否存在四个CoreCLR相关的目录，且目录中是否存在``UnityPlayer.dll``文件，如果其中一个存在则返回`true`，否则``false``
				- 其成员变量``m_AreCoreCLRPlayersInstalled``最终在初始化时被``AreCoreCLRPlayersInstalled``函数检查为false，因此最终导致了``DeskTopStandaloneBuildWindowExtension``类在GUI处输出CoreCLR 未安装的错误信息
					- ![image.png](../assets/image_1689665866216_0.png)
					- ![image.png](../assets/image_1689665595251_0.png)
	- ``Editor\Mono\BuildPipeline\DesktopStandalonePostProcessor.cs``被``WinPlayerPostProcessor``继承，并且在`PlatformDependent\WinPlayer\Extensions\Managed\ExtensionModule.cs` 的``CreateBuildPostprocessor``函数中完成实例化
- # Build行为
	- 规定了一些和编译有关的attribute
	  collapsed:: true
		- ![image.png](../assets/image_1689735709469_0.png)
- # [[Build系统行为]]
- # 尝试直接构建使用CoreCLR的Player
	- ## 使用``build.pl``
		- 使用``perl build.pl``指令通过互动的方式选择target和scriptingBackend构建
		- 或者``perl build.pl --scriptingBackend=coreclr``
		- 无法直接构建，报了一堆错，看报错信息好像是设计license问题和文件缺失
	- ## 使用``jam``
		- ``jam``支持很多版本的Player构建
			- 使用``./jam --help WinPlayer``查看所有支持的版本
			- ![image.png](../assets/image_1689761191221_0.png){:height 352, :width 269}
		- ``./jam WinPlayerCoreCLR``
		- 构建成功，``C:\engine\unity-reengineering\build\WindowsStandaloneSupport\Variations``下出现了代码中提到的文件夹
		- ![image.png](../assets/image_1689761066859_0.png)
		- 但是如此构建出来的player会出现错误
		  collapsed:: true
			- ![image.png](../assets/image_1689820015021_0.png)
		- 此错误应该出现在``PlatformDependent\WinPlayer\WinMain.cpp``的``LoadScriptingRuntime``函数
		  collapsed:: true
			- ![image.png](../assets/image_1689841299767_0.png)
		- 通过Debug输出，得到如下传入``LoadAndInitializeMono``函数的参数
		  collapsed:: true
			- ![image.png](../assets/image_1689841628031_0.png)
			- ![image.png](../assets/image_1689841643298_0.png)
			- ![image.png](../assets/image_1689841403930_0.png)
			- ![image.png](../assets/image_1689841428706_0.png)
			- ![image.png](../assets/image_1689841444059_0.png)
		- 感觉是根本没有把Mono运行时相关的东西拷过来，**尝试直接拷贝**
		  collapsed:: true
			- 将mono build的Mono运行时拷贝过来之后，不再报加载mono错误，但是程序无法正常执行，没有任何反应直接退出了
			- 而且在存在Mono运行时的目录下，Editor构建player会报错
			  collapsed:: true
				- ![image.png](../assets/image_1689844755644_0.png)
				- ![image.png](../assets/image_1689844780295_0.png)
			- 这个报错信息是在``PlatformDependent\WinPlayer\Extensions\Managed\WinPlayerPostProcessor.cs``中的``PrepareForBuild``函数中报的
			  collapsed:: true
				- ![image.png](../assets/image_1689848785415_0.png)
				- 这个函数会检测build目录下是否存在一些列runtime的目录，如果存在即将其存于变量``originalScriptingBackend``中
				- 如果``originalScriptingBackend``不为空且与当前选择的backend不一致则抛出错误
		- ### 尝试搞清楚player在哪一步退出
			- 根据断点结果，因该是挂在了``Runtime\Mono\MonoManager.cpp``的第2444行
			- ![image.png](../assets/image_1690180991966_0.png)
			- 这个函数应该已经是dll库中的函数，无法在debugger中继续跳转跟踪
			- editor和mono build的player都会经过这一语句，但是都正常运行，只有在coreclr build的player会出现这个问题
			- [[$red]]==**有没有办法跟踪dll中的函数？**==
			- 在``External\MonoBleedingEdge\builds\include\mono\mono\jit\jit.h``文件中有此函数的定义，不知道和实际函数实现和符号引入有什么关系
				- ![image.png](../assets/image_1690181492377_0.png)
	- ## 查看coreclr player build目录下的coreclr运行时
		- ``CoreCLR``目录下有两个目录
		- ![image.png](../assets/image_1689845556037_0.png)
		- ``native``目录下有一个`dotnet.exe`可执行文件，但是似乎不可执行
			- ![image.png](../assets/image_1689845655698_0.png)
		- 将发行版本.NET目录下的``host/fxr``目录拷贝过来之后，有如下输出：
			- ![image.png](../assets/image_1689845729017_0.png)
			- ![image.png](../assets/image_1689845750822_0.png)
	-
		-
- # 和native hosting相关的代码
	- ## 调用托管方法
		- 没有看到直接使用mono API 调用托管方法的代码，感觉可能是unity自己封装了调用函数
		- 可能的封装函数：
			- ``Runtime\Mono\MonoUtility.h`` 中的``mono_runtime_invoke_profiled``函数
				- 此函数有注释：``/// Never call mono_runtime_invoke directly, otherwise the profiler will not be able to pick it up!``
				- ![image.png](../assets/image_1691405058550_0.png)
			- ``Runtime\ScriptingBackend\Mono\ScriptingApi_Mono.cpp``中的``scripting_method_invoke``函数
				- 其所需的形参之一``method``的类``ScriptingMethodPtr``是对Mono API中提供的托管方法指针``MonoMethod*``的封装
- # 两方代码对比
	- ## 项目结构
		- ### 根目录
			- 22目前的根目录结构
				- ![image.png](../assets/image_1691480285018_0.png)
			- 23的一级目录(根目录)结构和22的一致
			- 23中的``UnityPlayer.dll``和``build\WindowsStandaloneSupport\Variations\win64_player_development_coreclr``目录下的``UnityPlayer.dll``完全一致(大小在字节单位下都是完全相同的)
				- 意味着这个`.dll`文件应该是在bee建造时完成编译的
			- 22中的``UnityPlayer.dll``和`build\WindowsStandaloneSupport\Variations\win64_player_development_coreclr`中的不一致
				- 实际上22的项目目录下只有``TuanjiePlayer.dll``，且这个文件和``UnityPlayer.dll``大小不一致
				- 意味着22的Editor在建造player时可能做了一些额外操作
		- ### ``CoreCLR``
			- 看了下22的``native``下的``corelcr.dll``的输出符号，其中好像已经包含了很多的mono库函数，说不定global已经实现了用coreclr包装mono api
				- 并没有，比如``mono_unity_heap_validation_from_statics`` api就没有实现，不能直接用
				- 如果强行修改``funcsOK``的值继续运行，则会在``Runtime\Scripting\ScriptingProfiler.cpp``的719行挂掉
					- ![image.png](../assets/image_1691577593847_0.png){:height 57, :width 390}
			- [[$red]]==**总的来说，这个目录就是从**==``build\WindowsStandaloneSupport\Variations\CoreCLRShared\x64\CoreCLR``拷贝过来的，而``CoreCLRShared``下的这些目录又应该是stevedore在建造时下载
				- 但是这个从stevedore下载包的逻辑我没有看懂
				- 目前的猜测是：``PlatformDependent\WinPlayer\WinStandaloneSupport.cs``中的``SetupCopiesOfSupportFilesFor``函数负责CoreCLR相关文件的下载
				- 但是其调用的``Tools\Bee\Bee.Core\Stevedore\StevedoreArtifact.cs``的``UnpackToUnusualLocation``函数我看不太懂
			- 22的``CoreCLR``目录非常臃肿，感觉就是处于开发中的目录结构
			- 23的``CoreCLR``目录相比22，有如下不同：
				- **在``native``**目录下
					- **[[$blue]]==新增==**``runtime``文件夹
					- 没有那一堆``api-ms-win-core-xxxxx.dll``
					- **[[$blue]]==新增==**``clrgc.dll``和``clgc.pdb``
					  id:: 64d1f57c-612a-47c1-bf40-564a46196867
						- dll在``C:\Program Files\dotnet\shared\Microsoft.NETCore.App\<version>``目录下能找到
						- pdb在dotnet安装目录下没有，推测可能需要从NuGet或stevedore上获取
					- 没有``comhost.dll``
					- 没有``dotnet.exe``
					- 没有``coreclr_delegates.h``
					- 没有``corerun.pdb``
					- 没有``dbgshim.dll``和``dbgshim.pdb``
					- 没有``hotfxr.h``
					- 没有``ijwhost.dll``和``ijwhost.lib``
					- 没有``libhostfxr.lib``
					- 没有``libnethost.lib``
					- 没有``Microsoft.DiaSymReader.Native.amd64.dll``
						- 但是新增的``runtime``文件夹下有
					- 没有``nethost.dll``，``nethost.h``和``nethost.lib``
					- 没有``signlefilehost.exe``
					- 没有``ucrtbase.dll``
					- 除了runtime文件夹外，一共有30个文件
					- 在``runtime``目录下，23新增了多个和平台相关的文件夹，例如``win``，``win-x64``，``win-arm64``等
				- **在``lib``目录下**
					- 22包含目录``net7.0``
					- 23包含目录``net8.0``
			- 在``Editor\Src\BuildPipeline\BuildPlayer.cpp``的``GetCoreCLRReferenceDirectories``函数中，
				- ![image.png](../assets/image_1691486480929_0.png)
				- 23直接将``managed_directory``硬性编码改为了``lib/net8.0``
			- #### ``lib``目录
				- 如上所述，``lib``目录下的7.0被改为了8.0
				- 对比发行版的.net8库(``C:\Program Files\dotnet\shared\Microsoft.NETCore.App\8.0.0-preview.6.23329.7``)发现23的``lib\net8.0``的文件和发行版的库文件高度一致，不过多了很多debug文件(``.pdb``,`.xml`)文件，基本上每`个.dll`文件就会对应一个`.pdb`和`.xml`文件
				- 只有``unity-embed-host.dll``这个文件是发行版中没有的，**[[$blue]]==其关键可能也在于此==**
				  id:: 64d32b30-3e59-4e1f-9466-154e0b6e3b95
	- ## 代码
		- 从palyer的native代码看来，CoreCLR和Mono的不同主要就集中在控制加载``.dll``的行为
		- 在``Runtime\Mono\MonoManager.cpp``中的``SetupMonoPaths``函数会根据选择mono还是coreclr存储不同的库文件路径
			- ``Runtime\Mono\MonoManager.cpp``在23中已经被改名``MonoBootstrap.cpp``
			-