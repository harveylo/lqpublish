- # CMake是什么？
	- CMake是一个高级编译配置工具，全程为**Cross Platform Make**，比``make``更高一级
	- 可以根据简单的语句来**描述**所有平台的安装(编译)过程
	- 最初是作为Makefile生成器，但现在已经能够输出各种各样的**makefile**或者**project**文件，类似于Unix下的**automake**
	- CMake的configuration file名叫``CMakeList.txt``
	- CMake并不直接建构出最终软件，而是产生标准的construct file，例如Unix的Makefile，visual C++的projects/worspaces，然后再使用一般的建构方式使用
	- 所以对于C或者C++项目来说，使用CMake的**一般流程**是：编写``CMakeList.txt``-> 运行``cmake``构建出项目 -> 运行``make``正式编译项目
	- CMake可以
		- 编译源代码
		- 制作程序库
		- 产生适配器(wrapper)
		- 以任意顺序构建可执行程序
	- CMake的**建造系统(build system)**由若干高级别的**逻辑目标(logical target)**组成。
		- 每一个目标都对应一个可执行文件或库，或包含自定义命令的自定义目标
		- 每当调用``ADD_EXECUTABLE``，``ADD_LIBRARY``等命令时都填见了一个逻辑目标
		- 每一个逻辑目标拥有若干**目标属性**，例如其输出文件名(OUTPUT_NAME)等
- # CMake语言和项目组织结构
	- CMake的输入文件应该使用CMake语言编写，放置于``CMakeLists.txt``或``.cmake``文件中
	- 一个项目中的CMake源文件被组织为：
		- **目录(Dicrectories)**
			- 格式：``CMakeLists.txt``
			- 当CMake处理一个项目源树(Source Tree)时，入口就是一个位于最顶层源目录(source directory)的名为**CMakeLists.txt**的文件
			- 该文件可能包含了所有的构建specification，也可以使用``add_subdirectory()``添加建造子目录
				- 每一个使用该命令添加的建造子目录也必须包含一个``CMakeLists.txt``文件作为该目录的entry point
			- 对于每一个被处理的源目录，CMake会再建造树上生成一个对应目录作为默认的工作和输出目录
		- **脚本(Scripts)**
			- 格式：``<scripts>.cmake``
			- ``cmake``使用``-P``选项可以直接执行使用CMake语言编写的脚本
				- 仅仅执行其中的语句，不生成建造系统，因此不允许含有定义了建造目标或者行为的语句
		- **模块(Modules)**
			- 格式：``<module>.cmake``
			- 目录和脚本中的cmake语言代码都可以包含``include()``语句来在当前scope和context下装载一个cmake模块源文件
			- ``man 7 cmake-module``可以查看已安装的cmake distribution自带的模块
			- 项目也可以提供自己的模块，用``CMAKE_MODULE_PATH``来指定这些模块的位置
- # 基本语法
	- [Manual Page](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html)
	- 一个CMake的源文件由若干**文件元素**组成
	- 一个**文件元素**可能是一个**命令调用(command invocation)**，也有可能是一个**括号注释**
	- **命令调用**由**命令标识符**和由括号括起来的若干参数组成
	- 参数之间可以用空格分割也可以用新起一行来分割
		- 也可以使用分号分割，但是已经**不推荐**，使用分号分隔会得到一个针对开发者的警告
		- 由于参数是用空格进行分割，如果参数名本身带有空格，要使用双引号括起来(显而易见)
- # [[CMake构建系统]]
- # 构建项目
	- 在shell中使用cmake构建项目构建系统时需要指定项目的源码目录
	- 也可以用选项``-B``指定build目录，若不给出，默认使用当前目录作为build目录，生成的各种临时文件也会直接存放于此，如果直接在源码目录下cmake，会扰乱当前目录的组织形式
	- 因此建议在构建一个项目时，要么在源目录下新建一个``build``目录，然后进入该目录中运行命令``cmake ..``，要么显示指定构建目录``cmake -S . -B build``
	- 在构建完成完成项目构建系统之后，可以直接运行对应的构建系统的指令进行实际的编译工作，也可以使用``cmake --build <build system directory>``进行项目编译，[[$red]]==**注意是经过cmake构建出来的项目构建系统目录，而不是源码目录**==如果新建了一个build目录来存放项目构建系统，则使用``cmake --build``时就应该指明``build``目录
- # 简单的工程目录结构
	- 一个工程项目的目录结构并没有定式，但是一般会遵守一些固有的习惯
	- 一般会有一个``src``目录用于存放源代码
	- 一般会有一个``doc``目录用于存放工程文档
	- 一般会有一个README文件对工程项目做简单的介绍
	- 可能会有一个``COPYRIGHT``文件介绍工程的知识产权信息
	- 可以添加一些``.sh``脚本用于调试，可以放在``scripts``目录下
	- 在这样的工程目录结构下，一般希望将构建后的目标文件放入构建目录(``build``)下的``bin``目录，将``doc``目录下的内容和COPYRIGHT，README一起安装到``/usr/share/doc/cmake``下
- # 一些简单技巧
	- ## 同时设置名称相同的动态库和静态库
		- 直接使用两个``ADD_LIBRARY``指令是无法同时创建同名的静态库和动态库的
		- 虽然可以通过更改其中一个库的名字，但是还是期望能够让静态库和动态库的名称相同，后缀名不同
		- 通过修改目标属性可以完成这项操作
			- 首先添加两个项目内名称不同的库
			- 将它们的输出名字设为相同
			- 将它们的``CLEAN_DIRECT_OUTPUT``属性设置为1
				- [[$red]]==**注意！**==在版本2.6之后，此属性已经被移除，然后此属性的相关行为一直开启
				- **即：**不再需要这一步，此步骤在2.6之后的版本可以直接被忽略
	- ## 设置版本号的关联
		- 一个动态库可以拥有一个build版本号和一个API版本号，分别使用``VERSION``和``SOVERSION``属性来设置
- # CMake命令行
	- 使用``cmake``指令即可开始对项目进行构造
	- 在构造时需要指定源目录，也可以选择构造目录
	- 源目录可以直接在命令之后第一个给出，也可以使用``-S``显式给出
	- 构造目录若不给出则默认为``PWD``，也可以使用``-B``显式给出
	- 可以直接通过``-D<VARIABLENAME>=<VALUE>``的方式定义处理过程中要用到的变量的值(也可以定义cmake自带的变量的值)
- # [[CMake基本命令]]
- # [[CMake常用变量]]