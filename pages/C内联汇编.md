- [参见](https://www.jianshu.com/p/1782e14a0766)
- 相当于使用汇编语言写内联函数
- 使用**asm**关键字标识内联函数的声明
- 能够操作c语言的变量
- # 汇编格式
	- GCC使用AT&T汇编语法
		- ``Op-dode src dst``
		- 使用寄存器要加%
		- 立即数必须有有\$前缀，引用C语言静态变量也必须要放上$前缀
			- 用0x标识16进制数
		- 操作符的最后一个字符决定操作数访问内存的长度
			- b：字节
			- w：字(16字节)
			- l：32字节
		- 内存操作数：
			- section: disp(base, index, scale)
			- 常数用作disp或scale时，不加前缀$
- # 基本内联汇编
	- 格式：``asm("assembly code")``
	- 当asm和程序中其他变量有冲突时，可以改用``__asm__``
	- 如果内联汇编有多条指令，每行要加上双引号，且改行以``\n\t``结尾
	- 例子：
		- ```
		  __asm__ ( "movl %eax, %ebx\n\t"
		                   "movl $56, %esi\n\t"
		                   "movl %ecx, $label(%edx,%ebx,$4)\n\t"
		                   "movb %ah, (%ebx)");
		  ```
	- 在内联代码中操作一些寄存器很有可能会产生一些难以预料的情况
		- 要避免可以在退出时做一些还原操作
- # 和register关键字一起使用
	- 格式类似于``register $(type) $(VA_NAME) asm ("$(GPR)");``
	- ``register``关键**词本来是用于**暗示寄存器此变量将被频繁访问，**建议放置在寄存器中**
		- 意味着定义的register变量必须是**CPU寄存器支持**的类型
			- 通常必须是一个单个的基础类型，且长度应该小于或者等于整型长度
			- 某的机器也支持浮点数
		- register变量不能存放于内存中，所以不能使用``&``来获取register变量的地址
		- 只有局部自动变量和形参可以定义为寄存器变量，全局变量不行[[$red]]==(?)==
			- 两个原因，一是让一个变量全程占据一个寄存器并不明智，二是在编译时每一个.c文件都需要被独立编译，因此无法在不知道其他文件对于寄存器占用的情况下分配全局寄存器变量
		- **局部静态变量不能**定义为寄存器变量
		- 过多且过于密集的register声明可能会导致这些变量不能真正被存放于寄存器中
	- 可以用于定义**全局寄存器变量**，也可用于定义**局部寄存器变量**
	- ## 定义全局寄存器变量
		- [Global register variable](https://gcc.gnu.org/onlinedocs/gcc/Global-Register-Variables.html#Global-Register-Variables)
		- 定义语句在函数之外(废话)
		- **不能**和``static``关键词一起使用
		- **不能**和``const``，``volatile``关键字一起使用，因为可能会导致矛盾的结果
			- 例如使用``volatile``关键字并不能完全阻止编译器将此变量优化为从寄存器读取(``register``关键字的含义和volatile相反)
		- 一般来说由于寄存器的稀缺属性，让编译器来分配寄存器的使用往往能获得最佳的性能，但是在某些情况下，分配全局的寄存器变量也是合理的(例如某个变量需要被频繁地全局访问)
		- 在定义好全局寄存器变量之后，在当前的汇编单元(compilation unit，.c源文件)中
			- 如果指定的寄存器是被调用者保存(call-saved)寄存器，那么在变量被赋值之后，function epilogue阶段中该寄存器并不会被恢复，对于遵守标准ABI的调用者来说，这样的返回并不安全
			- 反之如果是调用者保存，那么在标准ABI下进行调用可能会使得caller丢失变量的值。更为重要的是这样的调用很多可能是隐式的，即源码中并没有，但是编译器优化使用了一些库函数来完成相关工作
			- 此寄存器在优化启后的某些情况下可能仍然能被其他变量使用，但是变量的值并不会受影响
			- 此变量如果使用在后续的内联汇编语句中，则必须使用限定词修饰，且不能用于一般的内联汇编语句中，必须是扩展内联汇编语句
		- 以上描述只针对参与汇编的代码，仅仅是被连接进来的代码(例如库函数)不受影响
		- 所以如果想对包括使用的库函数在内的所有代码都加上此限制(该寄存器仅保留给某一变量)，可以在编译时使用选项``-ffixed-reg``
		- ### 声明变量
			- 不能有初始值，因为程序被加载时不可能以任何方式提供寄存器的初始值
			- 尽量选择被调用者保存的寄存器，这样可以使得那些不知道此寄存器特殊性质的代码能够在return前恢复该寄存器的值
			- 在拥有**寄存器窗口**(register window)的机器上，要小心选择寄存器，以免被函数调用机制影响
		- ### 使用变量
			- 如果调用一个对寄存器保留并不知情的函数，那么小心这些函数可能会回调一些使用该变量的函数
				- 例如，如果调用库函数qsort，哪怕选择了正确的寄存器使得qsort在return之前会恢复该寄存器的值，但是qsort自身在调用比较函数之前并不会恢复寄存器值，因此这个全局变量对于比较函数而言并不一定可靠
			- 类似地，在signal handler中或者多个线程控制中访问该变量都是不安全的，可能会导致在该寄存器中观察到一些无关的临时值
			- 在一些机器上，``longjmp``函数会恢复每个全局寄存器变量在调用``setjmp``时的值，但有些机器又不会。因此回了可移植性，调用setjmp的函数应该在调用时保存所有全局寄存器变量的值，然后在调用longjmp时恢复素有全局寄存器变量的值
	- ## 定义局部寄存器变量
		- [Local register variable](https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html)
		- 形式和全局寄存器变量一直，但是在函数内部定义(废话)
		- 局部寄存器变量的唯一用途是在扩展内联汇编语句中作为带有限定词输入输出使用，且在对这些变量赋初始值时，建议多使用临时变量防止register clobber
		- 以下使用局部寄存器变量的方法是不被支持的
			- 用于向基础内联汇编语句中传递参数
			- 用于向没有指定输入输出操作数的扩展内联汇编语句传递参数
			- 用于向使用非标准调用规则的汇编或其他语言的routine传递参数
		- 也不建议使用局部寄存器变量用于函数性能优化，局部寄存器变量对于compiler来说只是hint，并不保证这样的优化在每一次执行中都生效
- # 扩展内联汇编
	- 基本内联汇编只涉及到嵌入汇编指令
	- 扩展形式中，还可以指定操作数，选择输入输出寄存器，指明要修改的寄存器列表
		- 并不一定显式指明要访问的寄存器，可以留给gcc自己去选择
	- 格式：
		- ```
		  asm ( assembler template
		          : output operands                /* optional */
		          : input operands                   /* optional */
		          : list of clobbered registers   /* optional */
		  );
		  ```
	- ## 汇编模板
		- 就是嵌入在C程序中的汇编指令
		- 每条指令放在一个双引号内，或者将所有的指令都放着一个双引号内，然后使用``;``分割。
		- 每条指令都要包含一个分隔符。合法的分隔符是换行符(``\n``)或者分号。用换行符的时候通常后面放一个制表符``\t``。对此前文已经有所说明。
		- 访问C语言变量用%0,%1…等等。
	- ## 操作数
		- 操作数都要用带双引号的限定符去修饰
		- 格式为：``"constraint" (C expression)``
		- 输出操作数的限制要用"="来修饰
		- 限制主要用于指定操作数的寻址类型(内存寻址和寄存器寻址)，也用于指定使用的寄存器
		- 多个操作数之间**用逗号**隔开
		- 从第一个输出操作数为0开始算起，使用编号引用操作数
		- 如果输出表达式**不能直接寻址**，则需要指定寄存器来保存输出
		- 一般输出操作数必须是只写的
		- 使用**"r"**作为限定标识让gcc自己选择通用寄存器进行保存操作
	- ## Clobber List
		- 如果某个寄存器的值在asm指令中被改变了，需要在clobber list中显式地指出被修改地寄存器
		- 寄存器名字用双引号括起来，多个寄存器之间用逗号隔开
	- ## Volatile
		- 如果要求内联汇编的代码必须在程序对应的位置中被展开执行，而不会被编译器优化重排序，则可以加上volatile关键字，如果担心冲突，可以改用``__volatile__``
	- ## constraints
		- 待补充