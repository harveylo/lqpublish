- thread_loacl变量允许每一个线程拥有一个独立的变量实体
- 以下类型的变量可以被定义为thread_local
	- 位于某个**命名空间(namespace)**中的变量
	- **类静态成员**变量
	- 某个函数内部的本地变量
- 这些变量拥有**线程存储期(thread storage duration)**，其生命周期和作用域限定在所在线程中
- 命名空间中和类静态线程本地变量会在某个编译单元第一次使用此变量之前构造，但是**具体多久之前**则没有说明
	- [[$red]]==问题：==构造是一个运行时概念，为什么和**编译单元**这个编译时概念合在一起谈了？
	- 某些实现会在 线程开始时构造，而有的则会在某个线程第一次使用它们前的一瞬间构造线程
	- **言外之意：**若某个线程并不使用它们，那么并不保证这些线程本地变量会被创建
- 函数中的线程本地变量会在某一线程的控制流第一次流经其声明语句时初始化
	- 行为和本地静态变量类似
- 线程本地变量的特征也和静态变量类似：
	- 在任何进一步的初始化(例如动态初始化)之前都会被**初始化为0**
	- 如果线程本地变量的构造抛出了一个异常，则会调用std::terminate来中止应用
- 当线程函数返回时，线程本地变量的**析构函数**将会被调用
	- 由于线程本地变量的初始化是不确定的，线程本地变量的析构函数不能和其他任何线程本地变量有依赖
	- 如果析构函数出现异常，也会调用terminate
- 当一个线程调用``std::exit``之后，线程本地变量也会被摧毁
- 线程本地变量也可以被取地址，且可以被作为指针传递给其他线程来访问