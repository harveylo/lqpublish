- 并发服务器一般有如下实现方式
	- 多进程服务器：创建多个进程提供服务
	- 多路复用服务器：通过捆绑并统一管理IO对象提供服务
	- 多线程服务器：通过生成与客户端等量的线程提供服务
- 本章简单讲解多进程服务器的实现方法
	- [[$red]]==**注意**==：windows下并不支持此方法
- # 进程
	- 进程ID是大于2的整数
	- 使用``fork``函数创建当前正在运行(调用fork函数的)进程的副本并执行
		- **头文件**：``<unistd.h>``
		- **参数**：void
		- **返回值**：成功返回进程ID，失败返回-1
			- 实际上父进程和子进程的返回值亦有区别：
				- 父进程：返回子进程ID
				- 子进程：返回0
			- 可以通过这一点在后续处理中区分父子进程
- # 僵尸进程
	- 执行完后本应被销毁的进程继续在系统中留存并占用资源的进程就是僵尸进程
	- ## 产生僵尸进程的原因
		- 已经在主函数种返回的子进程不会被操作系统销毁，而是保留其返回值和资源，直到父进程接受了其返回值
		- 若父进程一直不接受返回值(有可能没有等待子进程返回值而直接终止)，则这些子进程就一直不被释放，成为了僵尸进程
	- ## 销毁僵尸进程的方法：
		- 有两个函数可以让父进程获取子进程的返回值，自然也销毁了子进程
		- 调用函数``wait``获取子进程返回值
			- **头文件**：``<sys/wait.h>``
			- **参数**：``int* statloc``
				- 接收子进程返回值的变量的指针
				- 返回值通过两个宏解读
					- **WIFEXITED**，如果子进程正常终止，为真
					- **WEXITSTATUS**，返回子进程的返回值
			- **返回值**：成功时返回终止的子进程的PID，失败返回-1
			- wait函数**[[$red]]==是阻塞式的==**，会阻塞直到任意子进程返回
		- 调用``waitpid``获取指定pid子进程的返回值
			- **参数**：``pid_t pid, int* statloc, int options``
				- pid是等待终止的子进程id，如果为-1，则此函数退化为wait函数，等待任意子进程解说
				- options用于传递头文件``sys/wait.h``中声明的常量**WNOHANG**，如果传入此项，则**不会进入阻塞状态**，**如果没有已终止的子进程，则返回0**
			- **返回值**：成功返回终止的子进程的ID，失败返回-1
- # 信号处理
	-