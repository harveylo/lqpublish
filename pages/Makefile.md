- 补充：[[gcc编译过程简介]]
- 需要掌握的两个概念
	- **目标**
		- 生成什么东西
	- **依赖**
		- 如何生成目标
- 写makefile应该是**面向依赖的**
- # 运行
	- 在当前项目文件夹下直接运行make命令（**make file必须命名为Makefile**）
	- 也可以指定编译某个目标，使用make {target_name}来编译
	- 运行时必须指定make 目标
		- 如果不指定，直接运行make命令，则以第一个目标位目标，即“**默认目标**”
	- 指定目标之后，回去执行指定目标下的规则
- # 规则
	- 规则制定了哪些目标将已怎样的方式生成
	- 在规则的命令前加上字符**@**可以在执行make时不打印该命令
	- ## 目标
		- 通过{target_name}:来指定
		- 可以定义多个目标
		- 在指定的目标下的代码必须有一个tab
		- 一条规则可以拥有多个目标
		- ### 假目标
			- 编写makefile时，有时需要一个并不希望其真正生成的目标，该目标的存在意义时作为一个命令行参数
			- 因此如果和该目标的同名文件存在于当前目录下时，make就会认为该目标已经最新而拒绝执行该目标下的命令
			- 此时就需要将该目标定义为**假目标**
				- 定义假目标需要提前使用关键字.PHONY:来提示跟在其后的都属于假目标，使其不与文件关联
				- 提示哪些目标属于假目标之后，规则照常编写
	- ## 依赖
		- 在某一目标的冒号之后可以指定其依赖于哪些目标和一些先决条件
		- 当编译某一个目标时，make会递归查询依赖文件是否存在，如果存在，其所依赖的文件是否已大于目标文件时间戳。依赖文件时间戳均小于目标文件的目标不会被再次make，即该目标下的所有命令都不会被执行，否则会从时间戳改变的目标开始，回溯make到最高层目标
	- ## 模式规则
		- ### 隐含规则
			- 使用**%**作为通配符，指定文件类型
				- 例如`%.o: %.c`
				- 依赖也可以不带**%**，含义是所有.o都依赖于显示给出的依赖
				- 此方法写的规则目标不会被自动补全，也不会被作为默认目标，某种程度相当于是不存在的目标
		- ### 静态模式规则
			- 更加灵活，可以指定多目标规则，且能够被补全，也会被作为默认目标
				- 形如`$(OBJS): %.o: %.c`
					- 含义是，OBJS中的所有名称都形如%.o，且都依赖于%.c
- # 变量
	- makefile中变量无类型（废话）
	- 直接使用`CC = gcc`的方式定义
	- 引用变量时使用\$(VAR_NAME)或\${VAR_NAME}获取变量值
	- ## 自动变量
		- 即一些预先定义好的变量符号
		- **使用自动变量可以免去当目标名称修改之后重新修改命令参数的步骤**
		- $@：标识当前规则中的目标
			- 如果当前规则中有多个目标，则指任何造成命令被执行的目标
		- $^：表示所有先决条件
		- $<：表示第一个先决条件
		- $*：目标模式中%的匹配部分，一般用于去后缀
			- 如果目标中没有模式定义，那么这个就无法被识别****
			- 但是在GNU make中，如果目标文件的后缀是可识别的那么\$\*就表示去掉后缀的字符串，如若目标含文件a.c，那么\$\*表示a
				- 并不推荐在没有使用模式规则的情况下使用该自动变量
		- 想输出\$字符，需要连续两个\$\$
		- 想输出\$@，需要写作：\\\$\$@
	- ## 特殊变量
		- **MAKE**
			- 其值为make
			- 用于在一个makefile中调用另一个makefile时使用
		- **MAKECMDGOALS**
			- 其值为在shell中调用make命令时所给的目标参数
			- 缺省时虽然make会自动选择第一个目标，但是MAKECMDGOALS仍然为空
	- ## 赋值类别
		- 使用=定义的变量时递归扩展赋值，会逐层展开直到无法展开为止
			- 存在死循环的情况
				- `foo = $(foo)`
		- 使用:=定义的是简单扩展赋值。
			- 取值时会去最早被简单扩展的赋值
			- 使用\$()去取值时，如果是=赋值，则会去该变量全局最后被赋的值，哪怕最后的赋值语句在取值语句之后。如果是:=赋值，则会取在取值语句之前最后一次被赋的值
		- 使用?=进行条件赋值
			- 当变量在之前没有被定义则赋值
			- 否则保持变量本身的值不变
		- 使用+=进行追加赋值，新的类容会被append到该变量所代表的值的末尾
		- 在make的命令行参数中可以指定变量赋值，该指定的值会全局覆盖所有文件类写的同名变量赋值
			- 可以在makefile文件中利用**override**关键字抵消命令行参数赋值的影响
- # 内置函数
	- **wildcard**
		- 使用方法：$(wildcard pattern..)
			- 例：`$(wildcard *.c)`
			- 一次性获取当前目录下所有符合pattern的对象名称
		- pattern使用通配符描述
	- **patsubst**
		- 模式替换（pattern substitute）
		- 使用方法：`$(patsubst {需要被替换的模式}, {替换模式}, {源对象})`
			- 例：`$(patsubst %.c, %.o, $(SRCS))`
				- SRCS储存了所有的.c源文件
				- 该函数把所有的.c文件名替换为.o
			-
		-