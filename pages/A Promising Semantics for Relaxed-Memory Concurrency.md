- ![Kang 等。 - A Promising Semantics for Relaxed-Memory Concurren.pdf](../assets/Kang_等。_-_A_Promising_Semantics_for_Relaxed-Memory_Concurren_1643357921088_0.pdf)
- [[APSRMC-DIC]]
- [[APSRMC-QA]]
- 在程序员视角下，最希望的内存模型是SC（sequential consistency），但是这样的内存模型会导致性能浪费，破坏硬件所做的优化
- 硬件视角下，主流的CPU（和编译器一起）都会进行指令的重排和乱序调度（执行）
- SC并不适用有以下几点原因：
	- 如前所述，性能问题
	- 编译器的一些优化并不能使用简单的SC语义来很好地描述（翻译，建模）
	- SC过于严格，很多并发算法并不需要如此严格地限制来保证其正确性。
- 因此大多数语言（java，c++）会提供relaxed（weak） memory model，程序员可以自行要求是否使用SC语义。
- 希望找到满足如下性质地内存模型：
	- 能够实现，能够满足常见地编译器优化方式，意味着需要能够支持多种指令重排和合并
	- 支持高级推理原则（heigh-level reasoning principle）。编译器和程序员可以在不用了解完整的若内存语义地情况下完成正确地并行程序地开发。
	- 应该最好避免使用未定义的行为（undefined behavior）来定义一个竞争(racy)程序的语义。
- [一个promis是一个线程做出的承诺，承诺会不确定地（nondeterministically）在未来的某一时刻对某个变量x写入值v](((62012608-a2eb-4426-b613-209b3c8e6ce7)))
	- 在其他线程看来，一个promise等同于一次随机读写，其他线程可以从一个promise里读值
	- 但是做出promise的线程不能从自己的promise里读值，必须等到自己fulfill这个promise之后才能读值。
		- 否则会破坏per-location coherence
	- 直观地来说，一个promise使得其他线程在写入实际完成前就能够观测到该次写入
	- 一个线程只有在满足本地有限步（不借助其他线程帮助）的情况下能够对响应变量写入值，才能对该变量做出promise
- Per-location coherence：一个线程对于不同内存地址的读写观察可能不一定按照固定顺序，但是对于某一个地址的读写一定是按照程序的时间顺序的。
- 在操作语义中加入时间戳，对于变量的记录不再是简单的地址到值的映射，内存会记录下对于任意地址的所有修改记录，一条修改记录形似：〈x:v@t〉
	- 时间戳是不会重复的 ((62093785-dfc2-4b2c-a54e-75d03ca5b288)) ？？
	- 对于每一个线程T，保持T自己产生或观察到的记录地址x到最大时间戳的写，称为T的内存视角
		- 因此当T想对一个地址x进行读时，必须读取大于等于自己内存视角里的时间戳的记录
		- 当T相对一个地址进行写时，选择的时间戳必须大于自己内存视角里的时间戳
- 对于此语义的两个修正：
	- 线程每执行一步，必须重新验证他所有还未解决（outstanding）的promise，确保所有的promise仍然能够被fulfill
	- 时间戳的全序（total order）是密集的（dense），这样才能让任何写操作都能找到合适的时间戳来完成promise