# 相关研究
	- ## 移动应用对于延迟的要求
		- 分为**硬期限(Hard Deadline)**和**软期限(Soft Deadline)**
		- ### 硬期限
			- 对于延迟非常敏感的应用程序，例如远程医疗手术，远程桌面应用程序等
			- 每个任务必须在Deadline前完成
		- ### 软期限
			- 可以适当容忍延迟的应用程序，例如视频分析应用程序，AR应用程序等
			- 可以被适当延迟执行
	- ## 预测用户移动性(Mobility)
		- 传动移动网络主要基于随机运动模型进行评估，但现实中用户的移动往往有一定目的性并受部分环境因素影响，移动并不完全随机
		- 近期研究表明，人类更倾向于执行**Lévy游走(walks)**，同时收到个人和社会特征，环境参数的强烈影响
- # 方法和步骤
	- ## 系统模型
		- ### 计算任务模型
			- 每一个计算任务$T$可以被三个项描述：$T = \{r^C,r^N,\tau^M\}$
				- $r^C$表示完成此任务所需的计算资源。单位为CPU周期(Cycles)
				- $r^N$表示此任务的计算输入，包括代码和文件等。单位为bit
				- $\tau^M$表示此任务能容忍的最大延迟。单位为纳秒(nano second)
			- 用户应用根据延迟需求和移动性模式(Mobility Pattern)的不同被分为三类(case)
				- Case 1：具有软期限且不具移动性或移动性被限制在单个MEC主机下的用户应用程序
					- 例如：博物馆导览程序
				- Case 2：具有严格硬期限但移动性被限制在单个MEC主机下的用户应用程序
					- 例如：远程医疗手术
				- Case 3：具有严格硬期限同时具有跨主机移动性的用户应用程序
					- 例如：通勤中的远程桌面
			- 考虑一组MEC主机的集合$\boldsymbol{H} = \{1,2,\ldots,h,\ldots H\}$
				- 每一台MEC主机都有一些指标，包括：
					- **最大计算能力**，单位为每秒时钟周期，即频率
					- **能效指标**，单位为每个CPU始终周期所需的焦耳
			- 所有的MEC主机被以层级关系部署，分为三层：
				- 第一层：无线节点(Radio Node)层
					- 此层使用$\boldsymbol{I}$标识$\boldsymbol{I}\in \boldsymbol{H}$
					- 此层中的某一个节点是移动应用卸载任务时的默认节点
						- 即，用户的移动设备总是会处于此层的某个节点的覆盖范围中
				- 第二层：网络汇聚点(Network Aggregation Points)层
				- 第三层：核心网络边缘(Edge of the core network)层
			- 使用集合$\boldsymbol{J}$标识所有有能力托管(host)用户应用的MEC主机集合
				- $\boldsymbol{J}\in \boldsymbol{H}$
				- $\boldsymbol{J} = \{1,2,\ldots,j,\ldots,J\}$
				- 这些节点满足了运行相关用户程序所需的需求包括，例如具有GPU等
		- ### 能量模型
			- 某个MEC主机的能量消耗由CPU，存储，内存和网络接口的使用量决定
				- 由于在其中，CPU的使用所消耗的能量中成决定性占比，主要关注CPU使用
			- 假设CPU的使用率(utilization ratio)会影响能量消耗的量
			- 建模**服务器的能量消耗**为：$E_s = \alpha E_{max} + (1-\alpha)E_{max}u$
				- $E_{max}$为服务器被完全占用时消耗的能量
				- $\alpha$是服务器闲置时能量消耗和完全占用时能量消耗的比值
					- 闲置能量消耗主要来自于电力运输的损耗和制冷设置的能量消耗
				- $u$是服务器被使用的比例
			- 一个被卸载的**计算任务的总体能量消耗**由两部分组成
				- 数据卸载消耗的能量
					- 有数据的上传和下载导致的能量消耗
					- 由于关注MEC的能量消耗，无线网络传输的能量消耗不考虑，因为对于所有MEC选择，这部分能耗都是相同的
					- 建模为$r^Ne^N_{i,j}$，其中
						- $e^N_{i,j}$是主机$i$和$j$之间及逆行数据卸载的能效，单位为焦耳每bit
				- 任务计算消耗的能量
					- 类似地，建模为$r^C,e^C_j$，其中
						- $e^C_j$是在主机$j$上计算任务的能效，单位是焦耳每CPU时钟周期
				- 因此，计算任务总的能量消耗为$r^Ne^N_{i,j}+r^Ce^C_j$
			- 一个设备应用更可能会卸载多个任务，若假设一共会卸载$n$个任务，那么**该应用所造成的总能量消耗为**：
				- $E_j = (\overline{r^N}*e^N{i,j}+\overline{r^C}*e^C_j)*n$
					- $\overline{r^N}$和$\overline{r^C}$分别表示在这些任务中的平均量
		- ### 延迟模型
			- 某次**计算卸载的总延迟**分为两部分
				- 数据卸载延迟
					- 由$\frac{r^N}{x^N_{i,j}}$决定，其中
						- $x^N_{i,j}$是被分配给用户的带宽。单位为bits per second
				- 任务计算延迟
					- 由$\frac{r^C}{x^C_j}$确定，其中
						- $x^C_j$是主机$j$分配给此次分配给用户的计算资源。单位为CPU时钟周期每秒
			- 但是由于用户应用不一定是一直托管在同一台主机中，因此延迟可能会出现波动
		- ### 用户移动性模型
			- 考虑用户在一段时间内位于MEC主机覆盖覆盖区域中的情况
			- 考虑的总时间段(period)为一个时间段集合$\bold{P}$，其中每一个时间段为$p\in \bold{P}$，$\bold{P}=\{1,2,\ldots,p，p+1,\ldots,P\}$
			- 时间段之间是连续的，即上一个时间段的结束就是下一个时间段的开始
			- 即便用户在某一个时间段内一直停留在某台主机的范围内，其所提交的任务也有可能被优化算法托管到其他主机上
				- 但是此论文中的模型认为任务的移交**不会在某个时间段内发生**
				- 即用户提交的任务在某个时间段内一定仅运行在某一台主机上
			- 因此某个时间段所消耗的能源可以建模为：
				- $E^O_{p,j} = (\overline{r^N_p}*e^N_{p,i,j}+\overline{r^C_p}*e^C_{p,j})*n_p$，其中
					- $p\in \bold{P}$
					- $j\in \bold{J}$
					- $n_p$是时间段$p$内卸载的所有任务总数
					- $\overline{r^N_p}$和$\overline{r^C_p}$分别是这段时间内卸载任务的所需计算资源和数据输入的平均
					- $e^N_{p,i,j}$是此时间段内从$i$到$j$卸载数据的能效，单位焦耳每bit
					- $e^C_{p,j}$是此时间段内主机$j$的计算能效，单位焦耳每CPU时钟周期
			- 任务从某台主机**迁移(Migration)**到另一台主机也会消耗能量，而迁移过程中主要的能量消耗来自于数据卸载，因此在某个时间段$p$末尾发生的任务迁移所需的能量建模为：
				- $E^M_{p,j} = r^M_{p,j}e^M_{p,j}$，其中
					- $r^M_{p,j}$是迁移所需的数据传输，单位是bit
					- $e^M{p,j}$是迁移过程中的能效，单位是焦耳每bit
						- 当$p=P$时，$E^M_{p,j}=0$
		- ### 优化目标
			-