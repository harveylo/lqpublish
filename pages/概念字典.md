# 托管代码(Managed code)
	- 就是通过运行时(CLR, Core CLR, Mono)管理运行的代码
	- 运行时在托管运行的过程中提供了一些重要的服务，例如自动内存管理，边界检查，类型安全等
	- 相对的概念是**未托管代码(Unmanaged Code)**，也就是传统的C/C++程序
		- 未托管代码的所有细节，包括内存管理等都由程序员来管理，二进制文件直接由操作系统载入并执行
	- 托管代码使用.NET虚拟机支持的高级语言写成，例如C#,VB,F# 等。
	- 对于原生.NET原生支持的语言(也就是上面列出来的三种)，编译器对他们的编译并不是直接编译为机器码，而是编译为CIL(Common Intermediate Language)
	- C++既能被编译为CLI运行在CLR上，也能作为未托管代码直接编译为机器运行在目标平台上
	- ## 互操作性(Interoperability)
		- 简称interop
		- 即CLR允许调用未托管代码
			- 例如将未托管代码包装为库，然后直接调用进这些库函数中
		- 注意在使用这些未托管代码时，运行时提供的所有服务不再可用，实际的控制权已经完全移交给了未托管代码
- # Platform Invoke(P/Invoke)
	- [文档](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)
	- 应该可以翻译为平台调用
	- 允许访问/调用未托管库中函数和结构体的技术
	- P/Invoke API包含在``System``和``System.Runtime.InteropServices``命名空间下
- # 程序集(Assembly)
	- [文档](https://learn.microsoft.com/en-us/dotnet/standard/assembly/)
	- 在基于.NET的应用中，程序集是**部署，版本控制，重用，激活范围(activation scoping)和安全许可(security permission)的基础单位**
	- 一个程序集是一系列类型和资源的集合，他们一起组成了功能性上的逻辑单元
	- 程序集往往以**可执行程序(.exe)**和**动态链接库(.dll)**的形式存在
	- 它们给CLR提供其需要的有关类型实现的信息
- # Runtime Host
	- 从操作系统的角度来说，运行时不过就是一些dll动态库的集合
	- 在实际运行基于运行时的程序时，需要有**一个基础程序来载入并启动运行时**
	- 这个基础程序就是**Runtime Host**，载入并运行运行时的行为即称为**Hosting**
	- 一般来说不需要关心这个问题，因为安装的运行时会提供一个默认的Host，例如对于.NET来说，使用``dotnet run``时，就是使用默认的host来完成了运行时的载入和运行的工作
	- 但是也可以编写自己的自定义host程序，运行时一般都会提供相关的库函数来协助完成