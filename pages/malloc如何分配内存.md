- # 问题
	- ## ``malloc``是如何分配内存的？
		- 使用`malloc`或`sbrk`
	- ## ``malloc``分配的是物理内存吗？
		- [[$red]]==**不是**==，分配的是虚拟内存
		- 如果分配之后的内存并没有被访问，虚拟内存不会映射到物理内存，也就不会占用
		- 第一次访问已分配的的虚拟地址空间，操作系统通过查找页表会发现对应的页没有在物理内存中，会触发缺页中断，然后建立其虚拟内存到物理内存的映射关系
	- ## ``malloc(1)``会分配多大的内存
		- ``malloc``一般并不会完全按照用户申请的大小来分配内存空间，而是会**预分配更大的空间作为[[$red]]==内存池==**
	- ## ``free``释放内存，会归还给操作系统吗?
		- 通过``sbrk``分配的内存在``free``之后**并不会立即返还给操作系统**，而是进入内存池中，以待下一次分配请求
			- 这部分内存只有在进程推出之后，操作系统才会回收这部分内存
		- 通过``mmap``方式分配的内存``free``之后**会归还给操作系统**，操作系统可以重新分配物理内存
	- ## ``free``函数只传入一个内存地址，系统如何知道要释放多大的内存？
		- 在GNU实现下，``malloc``在分配内存时会在此内存块中分配一个header，描述此内存块的相关信息
		- 一般header为16字节，储存在内存块的低地址处，将给出的分配地址-16即可获得头部信息
		- ``free``在释放一个地址的内存块时，就是通过header获取大小信息，知道释放多大的内存
	- ## 在只有4GB物理内存的机器上，申请8GB内存会怎样？
		- **在32位机器上**，用户进程理论最大能申请的内存也就3GB，因此申请8G内存会直接失败
		- **在64位机器上**，最大理论能分配的内存是128TB虚拟内存，因此分配能成功分配，在被访问时会实际分配物理内存
			- **若没有开启swap机制**(swap分区，swap文件)，则会因为物理空间不够，在实际分配物理内存到达上限之后会因为OOM导致内存分配异常而被kill
			- **若开起了swap机制**，则会通过频繁换入换出访问超过物理内存的虚拟内存。
				- 但是也不代表真的可以无限制使用超过物理内存的虚拟内存，当访问的虚拟内存超过物理内存过大时，仍会被操作系统kill掉
- # Linux进程的内存分布
	- ![图片](https://cdn.xiaolincoding.com//mysql/other/1db038e1d2e5325b05e2bb80475d962a.png)
	- linux中虚拟地址空间被分为**内核空间**与**用户空间**
	- 处于**用户态**时，**[[$red]]==只能访问==用户空间的虚拟地址**
	- 处于**内核态**时，对于虚拟地址的访问**不受限**
	- 每个虚拟内存众多的内核地址都关联相同的物理内存(即内核在物理内存中的真实地址)
		- ![图片](https://cdn.xiaolincoding.com//mysql/other/c88bda5db60029f3ea57e4306e7da936.png)
	- ![虚拟内存空间划分](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png){:height 284, :width 360}
	- 栈的大小一般是``8MB``，也可以自定义大小
	- 堆和文件映射段是**动态分配的**
- # ``malloc``如何分配内存
	- ``malloc``函数自身不属于系统调用，但是其实现依赖系统调用
	- ``malloc``有两种方式向操作系统申请堆内存
		- 使用``sbrk``从堆分配内存
			- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/brk%E7%94%B3%E8%AF%B7.png)
			- 实际上就是将**brk(堆顶指针，break)**向高地址移动，获取新空间
		- 使用``mmap``从文件映射区域分配内存
			- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mmap%E7%94%B3%E8%AF%B7.png)
			- 可以看作从文件映射区偷了一块内存
	- 在**GNU libc**中：
		- **当用户要求分配的内存小于``128KB``**时，通过``sbrk``申请内存
		- **当用户要求分配的内存大于``128KB``**时，通过``mmap``申请内存
		- [[$red]]==**注意：**==不同的glibc版本，阈值不一定相同不同
		- [[$red]]==**注意**==：可以通过``mallopt``函数改变此阈值
- # ``sbrk``和``mmap``
	- ``mmap``的[[$blue]]==优点==
		- 申请的内存在``free``之后会返还给操作系统
	- ``mmap``的[[$red]]==缺点==
		- 由于每次都是直接从操作系统去拿新的内存，因此首次访问必定出现**缺页异常**
			- 这就是因为``free``的内存直接交还给操作系统导致的，也是没有内存池的弊端
		- 通过映射的方式申请内存会导致更多的系统调用和中断，**影响性能**
	- ``sbrk``的[[$blue]]==优点==
		- 有内存池，再次申请内存时，如果刚好拿到在内存池中的内存，不会出现缺页异常，同时因为是**分配整段连续内存**，**[[$blue]]==性能更好==**
	- ``sbrk``的[[$red]]==缺点==
		- ![图片](https://cdn.xiaolincoding.com//mysql/other/75edee0cb75450e7987a8a482b975bda.png){:height 368, :width 416}
		- [[$red]]==**可能会导致内部碎片**==，例如上途中，如果再要求分配一个30K以上的内存，则必须像操作系统申请更多的内存
		- 这种内部内存碎片，使用``valgrind``之类的工具是无法检测出来的
	- 因此，``malloc``，**[[$red]]==需要结合两种工具一起使用==**