# 进程
	- 一个加载进内存中，处于运行状态的程序
	- ## 对于进程的经典教科书阐释(八股)
		- 一个进程从创建到执行结束一共可能经历七个状态
			- ![image.png](../assets/image_1694158331441_0.png)
			- **创建态(new)**：进程刚被创建或正在被创建的状态
			- **就绪状态(ready)**：处于内存中，随时可以被调度执行
			- **运行状态(running)**：正在占用CPU时间片
			- **阻塞状态(blocked)**：正在等待某一时间发生(如输入输出，信号量，互斥量)。也称等待状态(wait)
			- **挂起阻塞(suspended blocked)**：进程被**换出到外存(磁盘)**中，等待某个事件发生
			- **挂起就绪(suspended ready)**：进程被换出到外存中，如果被加载到内存中随时可以被执行
			- **结束态(end)**：完成执行，正在从系统中退出的状态
		- **挂起(suspend)**指的是从内存中换出到硬盘上的行为。一般在内存不够的情况下，操作系统会选择将一些进程换出。被换出的进程重新在入内存的过程被称为换入
		- 用户也可以主动将内存挂起，例如使用``<C-Z>``发送信号或使用``sleep``库函数
	- ## 进程控制结构
		- 操作系统利用**PCB(Process Control Block)**记录和描述进程
		- PCB是**进程存在的唯一标识**，一个PCB实例一般包含：
			- **进程描述信息**，包含
				- 进程标识符，每个进程的唯一标识符
				- 用户标识符，标识进程所归属的用户，主要为了共享和安全性
			- **进程控制和管理信息**，包含
				- 进程当前状态，即上文中的new，ready等状态
				- 进程优先级，在支持抢占式调度时调度器需要根据进程优先级来确定下一个调度执行的进程
			- **资源分配清单**
				- 内存地址空间信息，所有打开的文件列表和使用的IO设备信息
			- **CPU相关信息**
				- CPU中各个寄存器的值和一些CPU状态信息，用于恢复执行时重建CPU状态
		- PCB通常通过**链表**的形式组织在一起，形成多个PCB队列
			- 将所有就绪的进程PCB通过链表组织在一起，构成：**就绪队列**
			- 将所有被阻塞的进程PCB通过链表组织在一起，构成：**阻塞队列**
	- ## 进程控制
		- ### 创建进程
			- 申请一个空白PCB，填入相关信息
			- 分配所需资源，如内存
			- 将新PCB插入就绪队列，等待被调度执行
		- ### 终止进程
			- 进程可通过三种方式被终止：
				- 正常结束
				- 异常(exception)结束
				- 外界干扰(kill信号)
			- 终止进程的过程一般为
				- 查找要终止的进程的PCB
				- 若处于执行状态，立即终止执行并释放CPU资源
				- 若其有子进程，将进程的子进程交予1号进程接管
				- 将该进程所拥有的资源(打开文件，占用的设备)释放
				- 将PCB出队
		- ### 阻塞进程
			- 找到需要阻塞的进程的PCB
			- 若该进程为运行状态，保存其上下文，将状态改编为阻塞态，停止运行
			- 将PCB插入到阻塞队列中
		- ### 唤醒进程
			- 一个进程从阻塞态中苏醒需要其他进程通知其所等待的事件已经发生，通常是负责处理这件事的进程来处理，例如处理IO的进程告知等待IO的进程IO操作已经完成
			- 唤醒步骤：
				- 在等待某事件的阻塞队列中哦找到相应进程的PCB
				- 将其出队，江金城状态置为就绪
				- 把PCB插入就绪队列，等待调度执行
			- 一个进程的阻塞语句和唤醒语句必须成对出现，否则可能出现死锁
	- ## 进程上下文切换
		- Context Switch
		- 在某一个核上，从一个进程切换到另一个进程运行的过程称为**进程上下文切换**
		- 上下文一般包括CPU通用寄存器，控制寄存器和程序计数器的值
		- 实际上，上下文切换是针对CPU状态而言，对于CPU自身来讲是**进程**还是**线程**抑或是**中断**导致的上下文切换，其并不可见，也不关心
		- 但是从程序员，或操作系统的角度来说，这三种不同的导致CPU上下文切换的原因需要被区别对待，因此细分出了：
			- 进程上下文切换
			- 线程上下文切换
			- 中断上下文切换
		- 进程的上下文资源还包括了内核堆栈等内核空间资源
		- 在进行进程上下文切换时，上下文会被保存在PCB中，以便后续恢复
- # 线程
	- 由于进程是一个正在运行的程序的抽象，因此如何让一个程序并发执行多个任务的问题自然而然导向了线程
	- 线程是进程下的某个具体任务的抽象，每个线程都共享进程资源，互相通信和任务调度的开销都明显小于进程
		- 所谓共享的进程资源，实际就是进程虚拟空间地址下的所有可访问资源
		- 由于线程并没有自己的虚拟地址空间，而是在进程地址空间下运行，因此进程地址空间下的所有资源都可供线程使用
	- 在进程内进行线程上下文切换时，由于大量的资源共享，只需要保存线程私有数据即可，即CPU寄存器和线程栈
-
-