- 有两种导致缓存**命中率**下降的问题：
	- **预读失效**
		- 每次从加载数据时都会额外多读一部分到缓存中，但程序可能每次都不适用这部分额外数据，这就是预读失效
	- **缓存污染**
		- 大批量读取数据，将热点数据挤出了缓存
- redis使用**LFU**算法来避免缓存污染
	- LFU会对最近使用的数据做访问计数
- MySQL和Linux使用**改进LRU算法**避免上述两个问题
- # Linux和MySQL的缓存
	- ## Linux
		- linux在应用程序读取文件数据时会将其缓存在文件系统的``Page Cache``中
		- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png){:height 578, :width 433}
		- 页缓存是在内存中的，可以减少对磁盘IO的调用
	- ## MySQL
		- Innodb储存引擎设计了一个**缓冲池**(Buffer Pool)，缓冲池**位于内存空间**
		- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png){:height 484, :width 355}
		- **读取数据时**，如果数据在缓冲池中，客户端直接读取缓冲池中的数据，否则去磁盘中读取
		- **修改数据时**，首先修改缓冲池中数据所在的页，然后设置脏位，后续由后台线程写入磁盘
- # 应对预读失效
	- linux基于页缓存提供**预读机制**
		- 应用程序读取少与4KB的数据时，操作系统仍然会读取至少4KB的数据，因为**刚好是一个页的大小**
		- **基于局部性原理**，会将后续的部分数据页载入内存
		- ![](https://cdn.xiaolincoding.com//mysql/other/ae8252378169c8c14b8b9907983f7d8b.png)
	- MySQL的InnoDB也提供类似地预读机制
	- 失效的预读可能会导致实际的热点数据被换出，而并未被使用的预读数据将会占据内存
	- ## 应对方式
		- **让预读页停留在内存的事件尽可能短**
		- ### Linux的改进
			- 实现**两个LRU链表**，[[$red]]==active_list, inactive_list==
			- **预读页只需要加入inactive_list**，当被真正访问时才插入active_list，若预读页一直没有被访问，随着淘汰的进行将会被从inactive_list移除
			- 如果**预读成功**，active_list末尾的数据并不会立即被淘汰，而是会被插入inactive_list头部，没有发生数据淘汰
		- ### MySQL的改进
			- 在LRU链表上**划分两个区域**：[[$red]]==young区，old区==
			- young区在**链表前半部分**，old区**在链表后半部分**
			- 这两个区域有各自的头和尾节点
			- young区和old区的长度**默认比是63:37**
			- 预读页加入old区头部，真正被访问时才插入young区头部
			- 若预读页一直没有被访问，则将很快会被从old区尾部淘汰
			- 被访问之后将会顶到young区头部，原来young区末尾的数据会被挤到old区头部
		- 两者的改进都是基于一个思想：**[[$red]]==将数据分为冷数据和热数据==**，分别进行LRU算法，而不是如同经典LRU一样所有数据**都只用一个LRU队列管理**
- # 应对缓存污染
	- 批量读取数据时，**若很多数据仅被访问一次**，按照之前的描述，缓存污染仍然会发生
	- 应对方式其实页很简单：**[[$red]]==增加进入active_list的门槛==**
	- ## Linux的应对方案
		- 批量扫描时，许多数据只是被访问一次 ，那么对于inactive_list中的数据**只有在第二次被访问时**才会被放入active_list
	- ## MySQL的应对方案
		- InnoDB中old区的内存页在被第二次访问时，**不会马上被升级到young区**
			- **如果第二次访问和第一次访问的间隔[[$red]]==在1秒以内==(默认值)**，则不会被从old区升级到young区
			- **如果第二次访问和第一次访问的间隔[[$red]]==在一秒以上==**，则该页会被从old区升级到young区
	- 提高活动区**准入门槛**可以很好避免缓存污染带来的影响
	-