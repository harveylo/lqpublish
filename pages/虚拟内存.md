- CPU直接操作物理内存地址
- 程序运行时如果不对物理地址进行封装，多程序并行时大概率出现**地址重叠**的情况，会互相干扰
- 因此程序跑在操作系统上时，操作系统和CPU会共同进行内存地址管理
	- 操作系统会为其分配**虚拟内存空间**
	- **虚拟内存空间到物理内存空间的映射**由操作系统和CPU**共同完成**
		- 操作系统提供**页表**
		- cpu提供**地址转换部件（MMU）**
	- ![进程的中间层](https://cdn.xiaolincoding.com//mysql/other/298fb68e3da94d767b02f2ed81ebf2c4.png){:height 229, :width 134}
- 虚拟地址到物理地址的转换路径为：
	- **第一步**：MMU中**分段单元**将**逻辑地址**转换为**线性地址**
	- **第二步**：MMU中**分页单元**将**线性地址**转换为**物理地址**
	- ![](https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png){:height 281, :width 473}
- # 内存分段(Segmentation)
	- ![](https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png){:height 481, :width 630}
	- 程序由若干**逻辑分段**组成，如代码段，数据段，栈段，堆段等
		- 不同的段有不同的属性，因此可**采用分段(segmentation)方式分离地址空间**
	- 分段机制下的虚拟地址由两部分组成
	  collapsed:: true
		- **段选择因子**(segment selector)
			- 保存在**段寄存器**中
			- 包括**段号(Index)**和其他位(**Table indicator(TI)**, **Requested Privilege Level(RPL)**)
				- 其中**TI**用于指示查找**GDT(Global Descriptor Table)**还是**LDT(Local Descriptor Table)**
					- GDT是所有任务共享的，是必需存在的表
					- LDT是某个任务单独拥有的，是可选表
					- 类似于linux中**进程page table**由进程单独拥有，**kernel page table**所有进程共享
					- 在实际分段应用中，**LDT**较少使用
		- **段内偏移量**(offset)
			- 位于0和**段界限(segment limits)**之间
			- 若段偏移量合法，将段基址加上段内偏移量得到物理内存地址
	- 虚拟地址通过段表与物理地址进行映射，分段机制会把**虚拟地址分成4个段**
		- 段0：**代码**
		- 段1：**数据**
		- 段2：**堆**
		- 段3：**栈**
		- ![](https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png){:height 306, :width 479}
	- ## 分段的缺点
		- 分段使程序可以使用虚拟地址，但是会导致两个缺点
		- ### 内存碎片(fragmentation)
			- **起因**：已经使用的内存在被回收之后可能会导致**空闲空间不连续**
			- 内存碎片分为**内部碎片(internal fragmentation)**和**外部碎片(external fragmentation)**
				- 内部碎片是操作系统给某个进程**分配的内存大于其所需内存**，程序在运行过程中从来不使用这些内存，操作系统也只能在进程退出后才能重新利用这些内存资源
				- 外部碎片是因为不连续的内存分配导致内存中存在很多小的空隙而无法分配出一整块较大的连续 内存
			- 分段可以做到按实际需求分配内存，因此**不会出现内部内存碎片**
			- 但是**每个段的长度不固定**，因此可能会导致**外部碎片**
			- 解决外部碎片的方法是**内存交换**
				- 把内存中的一块区域换出到硬盘上，再换入回内存中，但是紧贴着分配内存空间，将碎片合起来
				- Linux中硬盘上会由专门的``swap``空间，就是用于进行内存交换的
				- **[[$red]]==内存交换导致的换入换出会严重拖慢系统性能==**
- # 内存分页(Memory Paging)
	- 内存分段可能导致**外部碎片**，而解决外部碎片的**内存交换**又必然导致换入换出影响性能
	- **内存分页**即可解决此问题
	- 内存分页的**核心思想**是：[[$red]]==**将内存切分为许多固定大小的块**==，这样的块就是**页(page)**
		- 在Linux下，页的大小通常为``4KB``
	- ![](https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png){:height 310, :width 488}
	- 通过**页表(Page Table)**将虚拟地址映射到物理地址
		- 页表存储在**MMU**中，也是由MMU完成从虚拟地址到物理地址的计算
	-
-