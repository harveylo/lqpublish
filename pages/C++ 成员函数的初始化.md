- C++有三种方法可以初始化成员变量
	- **初始化列表**
		- ``A(int a, double b):a(a),b(b){}``
	- **构造函数初始化**
		- 在构造函数中对成员变量进行赋值
	- **声明时初始化**(就地初始化)
		- ``class A{ int a=1; }``
- 三种初始化方式在C++11之后都被支持
- 三种初始化方式可以共存，甚至可以作用在同一个成员变量上
	- 三种初始化方式的执行先后顺序为：
		- **声明时初始化** -> **初始化列表** -> **构造函数初始化**
	- 同一个成员变量如果经历了多次不同的初始化方式，后执行的初始化会覆盖之前的初始化结果
- # 三种初始化方式的适用场景
	- ## 就地初始化
		- 直观
		- 执行顺序是最早的，可以用于赋予最基本的初值，后续其他构造函数如果有需要可以覆盖修改
	- ## 初始化列表
		- const 成员变量不能在构造函数中初始化，只能在初始化列表中初始化或就地初始化
		- 引用成员也应当在初始化列表中初始化
		- 自定义类成员变量使用初始化列表初始化可以直接调用构造函数，避免额外的构造和拷贝开销(相较于在构造函数中初始化来说)
		- **[[$red]]==注意==**
			- 已经就地初始化的变量，在初始化列表中仍然可以被初始化，而且是**[[$red]]==覆盖初始化过程==**而不是**覆盖值**
			- 例如，一个常量已经就地初始化被赋予了一个值，在某个构造函数的初始化列表中，仍然可以再次初始化此常量变量，由于常量并不能再次被赋值，因此编译器实际做出的操作是覆盖了初始化的过程，不适用就地初始化而是使用了初始化列表中的初始化
			- 又例如，对于一个自定义类成员变量，也可以就地初始化，如``A a = A();``，在后续的构造函数的初始化列表中可以再次初始化此变量如``B():a(){}``，如果调用此构造函数来构造对象，那么a的构造函数只会被调用一次，再次验证了覆盖的是初始化过程，而不是再次调用变量类的构造函数覆盖值
				- 自定义类成员变量的就地初始化不可写做``A a()``，编译器会误以为你声明了一个返回值为A的函数a
		- 初始化列表的初始化顺序并不是按照初始化列表的顺序，**[[$red]]==而是按照变量在类中的声明顺序==**
			- 因此初始化列表中的某一个变量的初始化如果要使用到其他类成员变量，需要注意初始化顺序
	- ## 构造函数初始化
		- 实际上，在进入构造函数之前，所有的成员变量都已经完成了一次默认初始化，不管之前有没有显式的进行就地初始化或初始化列表初始化。
		- 所以在构造函数中的**初始化**实际是**赋值**，自然会导致额外的构造函数开销