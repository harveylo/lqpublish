- [[$red]]==**shell中的引号**==
	- 单引号不允许任何转义和命令执行，其中的所有字符均被作为普通字符对待
	- 双引号允许$参数替换和\`\`反引号命令替换
	- 而$()也能做到命题替换，在bash中建议使用
		- 其他shell不一定支持$()
- **cd -**：回到上一个目录
- 一个命令或多或少会有一些参数和argument
	- 对于参数的描述，[]括起来表示可选，...表示0或多个
	- 一般把“一个-和一个字母”组合起来的参数称为**flag**
- mv 指令可以用于**重命名**
- echo指令只会按顺序输出其收到的所有参数，因此不能直接重定向一个文件作为其输入
- tail，只输出输入的最后一行
	- -nX，输出最后X行
	- --line X 输出最后X行
- tee，将输入输出到一个文件，同时也打印到屏幕
- xdg-open，用系统默认程序打开文件
- diff，比较两个输入（文件）的差异
- 使用tldr查看命令作用，比man和help简洁
- clear：清屏或使用快捷键<C-L>，实际上只是翻页，并没有清除以前的消息
- reset：完全重置屏幕，但速度较慢
- printf "\033c"，bash 下可使用的full reset技巧，运行较reset更快
	- 自己写的clears命令
- # 常用命令集锦
	- ## 文件管理
		- `cd` ,  `pwd` ,  `mkdir` ,  `rmdir` ,  `ls` ,  `cp` ,  `rm` ,  `mv` ,  `tar`
	- ## 文件检索
		- `cat` ,  `more` ,  `less` ,  `head` ,  `tail` ,  `file` ,  `find`
	- ## 输入输出控制
		- 重定向, 管道,  `tee` ,  `xargs`
	- ## 文本处理
		- `vim` ,  `grep` ,  `awk` ,  `sed` ,  `sort` ,  `wc` ,  `uniq` ,  `cut` ,  `tr`
	- ## 正则表达式
	- ## 系统监控
		- `jobs` ,  `ps` ,  `top` ,  `kill` ,  `free` ,  `demsg` ,  `lsof`
- # 文件浏览
	- ls -l给出详细信息，最开头的d字母表示其是一个directory
		- 对于权限，第一组权限表示文件拥有者的权限，第二组是拥有该文件的用户组的权限，第三组是其他所有人的权限
		- 每一组权限包括r，w，x，表示读，写，运行
			- 对于文件来说 以上三个权限为字面意思
			- 对于directory来说
				- r，表示是否允许看到该目录下的文件
				- w，表示是否允许在该目录下重命名，删除，创建文件
				- x，表示是否允许搜索该目录
					- 意味着能否进入该目录，例如，cd 该目录，或者执行该目录下的任何文件
		- -R：递归展示
	- **tree**，可以更好地展示目录层次的命令
	- **broot**：一款非常强大的文件浏览工具
	- **nnn**：交互式文件浏览工具
	- **diff** ：比较两个文件的异同，输出格式为 [GNU Diff Format](https://www.gnu.org/software/diffutils/manual/html_node/Unified-Format.html)
	- **du** ： 统计磁盘占用情况
	-
- # root user
	- 在root下，command prompt的结尾为\#，而不是一般用户的$
	- 我作为super user 的权力是无限的
	- sudo，作为super user执行命令
	- /sys下的所有文件和目录其实是在文件系统中的各种设备和操作系统内核
		- class装着所有设备的种类
	- 提示命令行的井号表示目前作为root在执行命令，$表示不是
	- 在root用户下，输入exit可以退出root user
- **单双引号**
	- 双引号允许转义（$取值）
	- 单引号不允许转义
- # .sh脚本
	- 可以用source来执行脚本
	- 用 # **注释**
	- 在第一行的**shebang**告诉shell如何执行该脚本
		- 默认为#!/bin/bash
			- 此时shell就会常规使用bash来执行
		- 如果是一个python脚本，那就使用python的安装目录
			- 当不知道python安装的具体路径时，使用#!/user/bin/env python
	- 也可以使用source命令来预先载入一个写好的函数。
		- 载入之后仅在当前terminal有效
		- 也可以在脚本中用source来导入写在其他文件里的函数
	- **参数**
		- $n，获取第n个参数，从1开始
		- $?，获取上一个执行结束的函数的**错误代码**
			- 0，正常退出
			- 大于0，非正常退出或条件不成立
			- true命令的错误代码永远为0
			- false命令的错误代码永远为1
		- $0表示目前正在运行的脚本的名字
		- $# 表示参数的数量
		- $$表示当前正在运行的脚本的pid
		- $@表示所有参数的列表
		- $_，获取上一条命令的最后一个参数
		- !!，上一条命令，例如sudo !!可以快速作为root执行上一条指令
		- xagrs，将上一条命令的输出变回下一条指令的指令列表
	- 两条命令写在同一行，可以用;分割
	- $(命令)表示该命令的输出值
	- <(command)，**命令替换**， 会将命令的输出保存到一个临时的文件里，再将该文件作名作为参数给正在执行的命令
	  ``cat <(ls)``
		- 对于并不直接从标准输入获取参数而是从文件中获取内容的命令非常有效
	- **输入输出**
		- 标准输入stdin，标识符0
		- 标准输出stdout，标识符1
		- 标准错误stderr，标识符2
		- 输出>&输出，将两个输出合并
	- **条件判断**
		- 使用test命令
		- 或者'[[]]' 代替test
	- **通配符（wildcard characters）**，包含通配符的语句模式称为glob，使用通配符的行为叫globbing
		- *：0或多个字符
		- ?：单个字符
		- {}：用于expand，
			- image.{png,jpg} = image.png image.jpg
			- 可以多次使用
				- touch project{1,2}/src/test/demo{1,2,3}.sh
		- ..：表示从第一个开始到最后一个{a..j}
	- **debug**
		- 使用shellcheck
- # 查询
	- **find** 指令，[[$red]]==**查找文件和路径**==
		- 需要指定目录，用.指代当前目录
		- -name 指定名称，可以使用通配符
		- -path 表示查找路径，可以使用通配符
		- 一个替代的指令是fd（ubuntu下为fdfind）
	- **grep**，**[[$red]]==查找文件内容==**
		- 指定一个partten（regex，正则表达式）
		- 指定一个文件或从stdin中搜寻
		- -R，查找整个当前目录里的文件，需指定目录
		- 一个替代是**rg**
			- -C 接数字，表示展示n行的上下文
			- -u，不要忽略隐藏文件
			- --files-without-match，输出不匹配的文件而不是匹配成功的
			- -t，指定在那些类型的文件中查询
			- --stats，显示搜索的详细信息
		- 另一个替代是**ack**
		- **ag**也是一个替代
	- **fzf**
		- fuzz search
		- 一个互动式的grep
	- **查询所有历史指令**
		- 使用history指令
			- 后接数字表示展示近n条指令
		- crtl+r，往后查询第一条匹配的指令，再使用方向键就可定位到那条指令附近
	- **zsh**很好地实现了动态命令历史匹配
		-
		-
		-