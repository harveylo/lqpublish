- [[$red]]==**shell中的引号**==
	- 单引号不允许任何转义和命令执行，其中的所有字符均被作为普通字符对待
	- 双引号允许$参数替换和\`\`反引号命令替换
	- 而$()也能做到命题替换，在bash中建议使用
		- 其他shell不一定支持$()
- **cd -**：回到上一个目录
	- 上一个目录的路径可以通过环境变量``OLDPWD``查看
- 一个命令或多或少会有一些参数和argument
	- 对于参数的描述，[]括起来表示可选，...表示0或多个
	- 一般把“一个-和一个字母”组合起来的参数称为**flag**
- mv 指令可以用于**重命名**
- echo指令只会按顺序输出其收到的所有参数，因此不能直接重定向一个文件作为其输入
- tail，只输出输入的最后一行
	- -nX，输出最后X行
	- --line X 输出最后X行
- tee，将输入输出到一个文件，同时也打印到屏幕
- xdg-open，用系统默认程序打开文件
- diff，比较两个输入（文件）的差异
- 使用tldr查看命令作用，比man和help简洁
- clear：清屏或使用快捷键<C-L>，实际上只是翻页，并没有清除以前的消息
- reset：完全重置屏幕，但速度较慢
- printf "\033c"，bash 下可使用的full reset技巧，运行较reset更快
	- 自己写的clears命令
- **echo和printf的区别**
	- echo输出的内容会在末尾自带一个换行符`\n`，printf则完全按格式打印
- # 常用命令集锦
	- ## 文件管理
		- `cd` ,  `pwd` ,  `mkdir` ,  `rmdir` ,  `ls` ,  `cp` ,  `rm` ,  `mv` ,  `tar`
	- ## 文件检索
		- `cat` ,  `more` ,  `less` ,  `head` ,  `tail` ,  `file` ,  `find`
	- ## 输入输出控制
		- 重定向, 管道,  `tee` ,  `xargs`
	- ## 文本处理
		- `vim` ,  `grep` ,  `awk` ,  `sed` ,  `sort` ,  `wc` ,  `uniq` ,  `cut` ,  `tr`
	- ## 正则表达式
	- ## 系统监控
		- `jobs` ,  `ps` ,  `top` ,  `kill` ,  `free` ,  `demsg` ,  `lsof`
- # 文件浏览
	- ls -l给出详细信息，最开头的d字母表示其是一个directory
		- 对于权限，第一组权限表示文件拥有者的权限，第二组是拥有该文件的用户组的权限，第三组是其他所有人的权限
		- 每一组权限包括r，w，x，表示读，写，运行
			- 对于文件来说 以上三个权限为字面意思
			- 对于directory来说
				- r，表示是否允许看到该目录下的文件
				- w，表示是否允许在该目录下重命名，删除，创建文件
				- x，表示是否允许搜索该目录
					- 意味着能否进入该目录，例如，cd 该目录，或者执行该目录下的任何文件
		- -R：递归展示
	- **tree**，可以更好地展示目录层次的命令
	- **broot**：一款非常强大的文件浏览工具
	- **nnn**：交互式文件浏览工具
	- **diff** ：比较两个文件的异同，输出格式为 [GNU Diff Format](https://www.gnu.org/software/diffutils/manual/html_node/Unified-Format.html)
	- **du** ： 统计磁盘占用情况
	-
- # root user
	- 在root下，command prompt的结尾为\#，而不是一般用户的$
	- 我作为super user 的权力是无限的
	- sudo，作为super user执行命令
	- /sys下的所有文件和目录其实是在文件系统中的各种设备和操作系统内核
		- class装着所有设备的种类
	- 提示命令行的井号表示目前作为root在执行命令，$表示不是
	- 在root用户下，输入exit可以退出root user
- **单双引号**
	- 双引号允许转义（$取值）
	- 单引号不允许转义
- # .sh脚本
	- ## shell (脚本)中的括号使用
		- **$()**：表示命令替换，使用指令的输出替代指令本身所在的位置，也可以使用**\`\`**(两个反引号)
			- 例如：``echo $(ls)``
		- **()**：在一个**子shell**中执行一系列命令。由于是在子shell中执行的， 对于变量的改变不会影响当前shell
			- 例如：``(echo "in the subshell"; ls -l)``
			- 退出状态的值是整个命令列表的退出状态值
			- 命令之间用分号隔开，最后一个命令末尾可以不带分号
			- 也可以用于[[$red]]==**数组初始化**==，例如：``array=(a b c d)``
		- **{}**：在当前shell中执行一系列命令，不会创建子shell。对于变量的改变会影响当前shell
			- 例如：``{ tem=1; echo $tem}``
			- [[$red]]==**注意**==：由于一些历史原因，大括号是保留字，所以在构成命令组时，左大括号必须和后面的指令用空格隔开(右大括号可以不隔开，但是最后一个命令后面必须要有分号)
			- 可用于文件名替换，如
				- ``ls {ex1,ex2}.sh`` = ``ls ex1.sh ex2.sh``
				- ``ls {ex{1..3},ex4}.sh`` = ``ls {ex[1-3],ex4}.sh`` = ``ls ex1.sh ex2.sh ex3.sh ex4.sh``
		- **[]**：等同于``test``，为bash内部命令
		- **[[]]**：比`[]`更加通用
			- 双方括号之间不会发生**单词分割(word splitting)**和**文件名扩展(filename expansion)**，但是会发生**参数扩展(parameter expansion)**，**变量名扩展**，**命令替换**，**进程替换(process substitution)**，**波浪线扩展(tilde expansion)**和**引号去除(quote removal)**
			- 支持字符串模式匹配，甚至支持shell正则表达式，如``[[ hello == hell? ]]``返回结果为真(0)
			- ``[[]]``支持很多更加现代化的表达式方式，例如``&&, ||, <, >``等符号在[[]]中可以使用，但是在[]中会报错
		- **(())**：本身就是一个命令，表示做算数替换，
			- (())中的算术表达式的结果值为0则退出状态为1，若不为0则退出状态为0(包括逻辑判断式)。
			- 其中的运算符只要符合C语言规则均可，甚至可以是三目运算符
			- 单纯使用(())也可以定义变量的值，如``((a=5))``
			- 常用于算术比较，双括号的变量的结果无法获取
		- **$(())**：类似于(())，但是获得算术运算的值
		- **${}**：去变量的值，加大括号是为了更精确地界定变量名
	- 可以用source来执行脚本
	- 用 # **注释**
	- 在第一行的**shebang**告诉shell如何执行该脚本
		- 默认为#!/bin/bash
			- 此时shell就会常规使用bash来执行
		- 如果是一个python脚本，那就使用python的安装目录
			- 当不知道python安装的具体路径时，使用#!/user/bin/env python
	- 也可以使用source命令来预先载入一个写好的函数。
		- 载入之后仅在当前terminal有效
		- 也可以在脚本中用source来导入写在其他文件里的函数
	- ## $相关参数
		- $n，获取第n个参数，从1开始
		- \$*，所有参数列表，若用双引号括起来则不发生单词分割，如``"$*"``等于``"$1 S2 ... $n"``
		- \$@，所有参数的列表，若用双引号括起来则发生单词分割，如``"$@"``等于``"$1" "$2" ... "$n"``
		- $?，获取上一个执行结束的函数的**错误代码**
			- 0，正常退出
			- 大于0，非正常退出或条件不成立
			- true命令的错误代码永远为0
			- false命令的错误代码永远为1
		- $!表示shell最后运行的后台进程的PID
		- $-表示所有使用``set``命令设定的flag
		- $0表示目前正在运行的脚本的名字
		- $# 表示参数的数量
		- $$表示当前正在运行的脚本的pid
		- $_，获取上一条命令的最后一个参数
		- !!，上一条命令，例如sudo !!可以快速作为root执行上一条指令
		- xagrs，将上一条命令的输出变回下一条指令的指令列表
	- 两条命令写在同一行，可以用;分割
	- $(命令)表示该命令的输出值
	- <(command)，**命令替换**， 会将命令的输出保存到一个临时的文件里，再将该文件作名作为参数给正在执行的命令
	  ``cat <(ls)``
		- 对于并不直接从标准输入获取参数而是从文件中获取内容的命令非常有效
	- **输入输出**
		- 标准输入stdin，标识符0
		- 标准输出stdout，标识符1
		- 标准错误stderr，标识符2
		- 输出>&输出，将两个输出合并
	- **条件判断**
		- 使用test命令
		- 或者'[[]]' 代替test
	- **通配符（wildcard characters）**，包含通配符的语句模式称为glob，使用通配符的行为叫globbing
		- *：0或多个字符
		- ?：单个字符
		- {}：用于expand，
			- image.{png,jpg} = image.png image.jpg
			- 可以多次使用
				- touch project{1,2}/src/test/demo{1,2,3}.sh
		- ..：表示从第一个开始到最后一个{a..j}
	- **debug**
		- 使用shellcheck
- # 查询
	- **find** 指令，[[$red]]==**查找文件和路径**==
		- 需要指定目录，用.指代当前目录
		- -name 指定名称，可以使用通配符
		- -path 表示查找路径，可以使用通配符
		- 一个替代的指令是fd（ubuntu下为fdfind）
	- **grep**，**[[$red]]==查找文件内容==**
		- 指定一个partten（regex，正则表达式）
		- 指定一个文件或从stdin中搜寻
		- -R，查找整个当前目录里的文件，需指定目录
		- 一个替代是**rg**
			- -C 接数字，表示展示n行的上下文
			- -u，不要忽略隐藏文件
			- --files-without-match，输出不匹配的文件而不是匹配成功的
			- -t，指定在那些类型的文件中查询
			- --stats，显示搜索的详细信息
		- 另一个替代是**ack**
		- **ag**也是一个替代
	- **fzf**
		- fuzz search
		- 一个互动式的grep
	- **查询所有历史指令**
		- 使用history指令
			- 后接数字表示展示近n条指令
		- crtl+r，往后查询第一条匹配的指令，再使用方向键就可定位到那条指令附近
	- **zsh**很好地实现了动态命令历史匹配
- # 展开(Expansion)
	- ## ~ 展开
		- ``~``：展开为环境变量``HOME``的值，如果``HOME``没有设置，则替换为执行这条命令的用户的home目录
		- ``~+``：展开为当前目录(``PWD``)
		- ``~-``：展开为上一个目录(``OLDPWD``)
		- ``~N``：展开为``disr +N``
		- ``~+N``：同上
		- `~-N`：展开为``dirs -N``
- # man page
	- 在学习或了解一个命令时，最权威也最常用的工具就是man
	- 一般来说，每一个应用在安装时都会安装其自身对应的man page
	- 不仅是命令行工具有man page，库函数，系统调用等一般也有自己的man page
	- 使用``man``+ 欲查询的项目可以阅读man page
	- 使用``man man``可以查看man自己的man page，里面包括在man下的操作和一些其他介绍
	- [[$red]]==**注意！**==有的命令可冷属于shell的builtin指令，这些指令可能不含man page，在shell中使用help查看这些指令。如果想获取这些指令的帮助，使用``help``+指令名查看
	- ## man page的分类
		- 不同的man page种类有一个对应的分类(Section)号，在man page中会在名称后的括号中注明，例如``LS(1)``
		- **1**：可执行程序或shell指令
		- **2**：系统调用(由系统内核(kernel)提供的函数)
		- **3**：库函数(由程序库提供的函数)
		- **4**：特殊文件(一般位于``/dev``)
		- **6**：游戏
		- **7**：杂项(包括宏包和一些规范)，例如：``man 7 man``
		- **8**：系统管理命令(一般仅限root用户使用)
		- **9**：内核历程(kernal routines)，并非所有系统和man的实现都提供此节
			- 指的那些系统内核内部的操作，此节主要介绍那些给系统和驱动程序员使用的函数接口
	- ## snap和man page
		- snap似乎是在ubuntu上比apt更为先进的应用分发和管理平台，其上的软件版本一般比apt的更新
		- 但是使用snap安装的软件，其man page并不会直接存放于``MANPATH``中，而是在各个应用自己的路径下，导致使用man会找不到相关应用的man page
		- 遇到这种情况要么将man page目录移动到已添加进``MANPATH``中的目录下，要么将该软件目录下的man page目录添加到``MANPATH``中
		- 一般而言，使用snap安装的软件，其安装路径都位于``/snap/``下
		- 以``cmake``为例，使用snap安装3.25.2版本之后，其目录位于``/snap/cmake``
			- 其man page位于``/snap/cmake/current/man``，因此只要将该目录添加到``MANPATH``中就可以在man中查看到man page
			- 若未在current目录下，可以尝试查看``current/share``
			- 添加``MANPATH``可以通过在``~/.bashrc``中添加语句``export MANPATH=":/snap/cmake/current/man"``完成
			- 也可以在``/etc/profile``中添加MANPATH，为所有用户添加man page