- # 内存分配到回收过程
- ``malloc``分配内存之后并不会立即划分物理内存，只有当访问虚拟地址但出现**缺页异常**之后由操作系统处理之后才会实际划拨物理内存
- 若发生缺页异常之后没有足够的物理内存用于划拨，则会开始进行**回收**工作，分为两种
	- **后台内存回收(kswapd)**
		- 物理内存紧张时，会唤醒``kswapd``**(Kernel SWAP Daemon)**守护线程回收内存
		- 此线程的回收过程是**异步**的，不会阻塞进程执行
	- **直接内存回收(direct reclaim)**
		- 若后台异步回收跟不上内存申请的速度，将开始直接回收，此过程是**同步**的，会阻塞当前进程
- 若直接内存回收都**无法满足**此次内存申请，将触发**[[$red]]==OOM(out of memory) 机制==**
	- OOM机制被触发时说明内存问题已经相当严重，操作系统会使用**极端方式**释放内存
	- OOM会选择内存占用较高的进程，发送``SIGKILL``，如果无法释放足够的内存将会强制终止进程
	- OOM会根据**内存使用量**，**优先级**等因素判断kill哪些进程，也会尽量避免杀死关键进程，以保证系统稳定性
	- 触发OOM机制将可能影响系统稳定性，一些用户进程将可能被异常终止并丢失数据
- ![](https://cdn.xiaolincoding.com//mysql/other/2f61b0822b3c4a359f99770231981b07.png){:height 686, :width 504}
- # 可回收的内存
	- 主要由两类文件
	- ## 文件页(File-backed Page)
		- 内核缓存的**磁盘数据(Buffer)**和内核缓冲的**文件数据**(Cache)
		- 大部分文件也可以**直接被释放**
		- **[[$red]]==被修改过==**的文件页需要**先写回**才能释放
	- ## 匿名页(Anonymous Page)
		- 这部分内存不像文件页在磁盘上有直接的映射(**没有天然的持久化方案**)
		- 如**堆，栈**区的数据
		- 在之后可能还会被访问，**不能直接释放**，通过linux的**Swap机制**回收
		- 将数据换出到硬盘上，释放内存，**需要时换入**
	- 文件页和匿名页的回收一般都是基于**LRU**算法
		- 维护**两个双向链表**
			- [[$blue]]==**active_list**==，活跃的内存链表，存放最近被访问过的内存页
			- [[$blue]]==**inactive_list**==，不活跃内存链表，存放很少访问的内存页
				- 越接近链表尾部越不活跃，被回收时优先被回收
	- 通过``cat /proc/meminfo | grep -i active | sort``可以查看活跃和非活跃内存分别占内存的大小
		- 活跃和非活跃又各自可细分出文件页和匿名页
		- ```
		  Active:          1279308 kB
		  Active(anon):     861252 kB
		  Active(file):     418056 kB
		  Inactive:         143968 kB
		  Inactive(anon):     1828 kB
		  Inactive(file):   142140 kB
		  ```
- # 回收内存带来的性能影响
	- 后台回收相较于直接回收，性能损耗较小
	- 匿名页回收相较于文件页回收，读写，换入换出更频繁，IO次数更多，对性能损耗更大
	- ## 调整文件页和匿名页的回收倾向
		- 通过修改``/proc/sys/vm/swappiness``调整回收时选择匿名页和文件页的偏好
		- 此文件的范围为``0-100``，**数值越大越倾向于回收匿名页(即swappiness)**，反之更倾向于文件页
		- 一般建议设置为0，但是并不意味着一定不回收匿名页
	- ## 尽早触发``kswapd``内核线程异步回收
		- 通过``sar -B 1``(System Activity Reporter)命令观察**[[$red]]==直接内存回收和后台内存回收的情况==**
			- ``-B``指定显式分页统计信息
			- ``1``指定每隔1秒更新并显示信息
		- ```
		  08:57:04 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
		  08:57:06 PM      0.00      0.00      3.50      0.00      0.00      0.00      0.00      0.00      0.00
		  08:57:08 PM      0.00      6.00      3.00      0.00      0.00      0.00      0.00      0.00      0.00
		  08:57:10 PM      0.00      0.00      4.50      0.00     60.00      0.00      0.00      0.00      0.00
		  08:57:12 PM      0.00      0.00      3.50      0.00      0.00      0.00      0.00      0.00      0.00
		  ```
			- ``pgscank/s``：kswapd线程每秒扫描的page个数
			- ``pgscand/s``：应用程序在内存申请过程中每秒**直接扫描**的个数
			- ``pgsteal/s``：扫描的page中每秒被回收的个数(pgscank+pgscand)
		- 如果系统发生抖动且``pgscand``的数值很大，说明抖动大概率是直接内存回收导致的
		- ### 进行后台回收的阈值
			- 内核定义了**三个阈值**用于衡量当前剩余内存的充裕度
				- ![linux中对于内存充裕度的三个阈值](https://cdn.xiaolincoding.com//mysql/other/166bc9f5b7c545d89f1e36ab8dd772cf.png)
				- **页最小阈值**(pages_min)
				- **页低阈值**(pages_low)
				- **页高阈值**(pages_high)
			- ``kswapd``定期扫描内存使用情况，根据剩余内存``pages_free``进行内存回收工作
			- [[$green]]==绿色部分==：高于页高阈值，剩余内存充足，**暂不需**回收内存
			- [[$blue]]==蓝色部分==：小于页高阈值大于页低阈值，内存分配有压力但**暂不需**回收内存
			- ==黄色部分==：剩余内存低于页低阈值，大于页最小阈值，内存分配压力较大，**``kswapd``开始回收内存**，直到重回蓝色部分
			- [[$red]]==红色部分==：小于页最小阈值，**触发直接内存回收**，应用程序被阻塞
			- 页低阈值**可以通过``/proc/sys/vm/min_free_kbytes``**间接设置，此参数表示系统所保留空闲空间的最低限制
				- 其余的阈值通过此值计算得出：
				- ```
				  pages_min = min_free_kbytes
				  pages_low = pages_min*5/4
				  pages_high = pages_min*3/2
				  ```
				- 因此增大此值可以提前触发``kswapd``线程介入回收内存
					- 但是代价就是**降低了应用程序可使用的内存量**，一定程度上浪费了内存
					- 若留存给用户程序的内存太少，可能会在仅使用很少内存的情况下就触发``OOM``
- # NUMA框架下的内存回收策略
	- ## SMP和NUMA
		- ![SMP 与 NUMA 架构](https://cdn.xiaolincoding.com//mysql/other/feec409868070d8cd79aecad2895b531.png)
		- **Symmetric Multiprocessing**，对称式多处理器系统
			- 多个CPU处理器共享资源，**每个CPU的地位平等**，共享相同的物理资源
			- 也称**UMA**(Uniform Memory Access)
			- 随着处理器或处理器核心增多，所有核心都通过同一个总线访问内存，**会导致总线繁忙，每个CPU可用带宽减少**
		- **NUMA**(Non-Uniform memory access)，非一致存储访问结构
			- 将CPU进行分组，某一组CPU为一个Node
			- 每个node**有自己独立的资源，包括内存，IO等**
			- **在intel CPU中**node之间通过**QPI(Quick Path interconnect)**通信
			- 远端node访问其他node中的内存比本地访问慢很多
	- ## NUMA与内存回收
		- 在NUMA下，若某个node内存不足，其可以选择：
			- **从其他node的内存中寻找空闲内存**
			- **回收本地内存**
		- 在``/proc/sys/vm/zone_reclaim_mode``中可以定位回收行为
			- ``0``(默认值)：在回收本地内存之前，在其他Nodde寻找空闲内存
			- `1`：只回收本地内存
			- `2`：只回收本地内存，可以将文件页中的脏页写回硬盘
			- ``4``：只回收本地内存，可以进行swap操作
			- 一般建议设置为0
- # 在OOM时保护进程
	- 在触发oom之后，linux内核会调用``oom_badness``函数，此函数扫描系统中所有可以被终止的进程，对每个进程进行评估，评分最高的进程会被kill
	- 评估考虑两点因素
		- 每个进程**已经使用的物理内存页数**
		- 每个进程的**OOM校准值(oom_score_adj)**
			- 此参数通过``/proc/<pid>/oom_score_adj``改变，有效值在``-1000 ~ 1000``
			- **默认为0**，即最终分数只和以使用的内存有关
	- 降低``oom_score_adj``的值可以降低其触发oom时被kill的概率
	- 如果一个进程无论如何页不应该在oom时被kill，将``oom_score_adj``设置为-1000
	- 对于系统至关重要的服务，如``sshd``，建议设置为-1000，否则此进程挂掉之后将无法再登录系统
	- **[[$red]]==业务进程不建议设置为-1000==**，否则发生内存泄漏后，系统性能会被极大削弱且不会触发报警