- # 错误检测
	- 一般而言，错误检测是将有效载荷进行一些运算后得到用于标记有效载荷某种特性的额外信息
	- 这些额外信息将会随数据一起发送
	- 例如，以太网会在有效数据后部附上CRC，TLS会在数据后附上MAC，IP会在数据之前附上checksum
- # Checksum
	- 应用于**IP，TCP，UDP**
	- **优点**
		- 快速，廉价，哪怕是软件实现(非硬件)也可以很快
	- **缺点**
		- 鲁棒性不强
		- 只确保能检测出一位错误
		- 也能检测其他错误，但是不能做出很强的担保
	- **具体操作**
		- 将所有的数据看作若干16bit长度的字
		- 将所有字加起来，进位重新加回去
			- 0x8000+0x8000=0x0001
		- 翻转所有bit位(0xffff除外，若求和结果是0xffff，则校验和就是0xffff)
		- 收到信息之后，将所有的数据求和(包括校验和部分)，结果应该为0xffff
	- 在IP，TCP，UDP的校验和部分，如果为0**表示不使用校验和**
- # CRC(Cyclic redundancy code)
	- 应用于**以太网**
	- 以太网帧使用32位的CRC校验码
	- 是一种比较典型的链路层纠错方式
		- 对于硬件来说计算很快
		- 可以递增式计算
		- 对于物理层的突发错误检出率高
	- **优点**
		- 能检测任何2bit错误，任何连续长度小于c bit的错误和任何奇数错误
	- **缺点**
		- 无法检测所有错误，有$2^{-c}$的概率两个包拥有同样的CRC校验码
		- 计算复杂度高于校验和
			- 但是在如今的硬件水平下不算困难，尤其是硬件实现
	- **详细信息**
		- 把数据看作一个多项式M，每一项表示2的n次方，位为0表示该项不在多项式中，位为1表示在多项式中
		- 还需要一个用于生成CRC码的多项式G，求M/G，结果就是CRC码
- # MAC(Message authentication code)
	- 应用于**TLS**
	- **优点**
		- 对于恶意修改的鲁棒性很强
		- 在强MAC下，两条消息拥有同样code的可能性很低($2^{-c}$)
	- **缺点**
		- 对于错误的检测鲁棒性相对不高
	- **详细信息**
		- 用一个secret来生成，c=MAC(M,s), |c| << |M|
		- 如果知道M和s，可以验证c的正确性
		- 如果不知道s，很难生成c