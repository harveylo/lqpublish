- # 镜像(Image)
	- Docker镜像相当于linux中的一个**root文件系统**，如官方镜像ubuntu:18.04包含了完整的一套ububntu 18.04最小系统的root文件系统
	- Docker镜像是一个特殊的文件系统，提供：
		- 程序
		- 库
		- 资源
		- 配置文件
		- 配置参数
			- 匿名卷
			- 环境变量
			- 用户
			- 等
	- 镜像**不包含**任何**动态数据**([[$red]]==个人理解==：内存数据)
	- ## 分层存储
		- 由于镜像包含一个完整的root文件系统，其体积往往较大
		- Docker利用**Union FS**技术，将镜像文件设计分层存储架构
			- 所以严格来说一个镜像文件并非是一个简单的类似ISO的打包文件，而是一个虚拟概念
			- 由多层文件系统联合组成
		- 镜像构建时会分层构建，前一层是后一层的基础
			- 每一层构建完毕之后不再发生改变，没一层的变化只发生在本层
				- 例如在某一层删除上一层文件只是在本层将该文件标记为删除，不会实际改变上一层内容
				- 虽然最终运行容器时看不到该文件，但是该文件会一直跟随镜像
				- 因此构建镜像时要小心，每一层要在构建结束前清理掉额外的东西
			- 定制镜像可以在一个基础镜像上增添新层来快速完成
- # 容器(Container)
	- 一个容器可以被理解为是一个镜像的**实例**(instance)
	- 可以被创建，启动，停止，删除，暂停等
	- 容器实质是一个进程，但是拥有自己的**命名空间**，自己的root文件系统，网络配置，进程空间，用户ID空间
	- 容器内的进程运行在一个**隔离**的环境里
	- 容器在运行时会以镜像为基础层，在其上创建一个新的储存层，即容器存储层
		- 容器存储层的生命周期和容器保持一致，随着容器消亡而消亡
	- 按照Docker最佳实践要求，容器不应该想起存储层类写入任何数据，所有的文件写入操作都应该通过**数据卷(Volume)**，或者**绑定宿主目录**来完成
		- 对这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)读写，性能和稳定性更高
		- 数据卷的生存周期独立于容器，不会随着容器消亡
- # 仓库
	- 用于存储和分发镜像的服务
	- **Docker Registry**是这种服务的一个实例
	- 一个Docker Registry可以包含多个**仓库**(Repository)，每个仓库包含多个**标签**(Tag)，每个标签对应一个镜像
		- 一般来说，一个仓库用来分发**同一个软件**的不同版本，即一个仓库对应一个软件，不同的标签对应该软件的不同版本
		- 通过``<仓库名>:<标签>``格式来指定具体使用哪个软件的哪个镜像，默认使用``latest``标签，如：``ubuntu:16.04``
	- 仓库名通常形式为**两段式路径**，如``jwilder/nginx-proxy``
		- 前者代表Docker Registry多用户环境下的用户名
		- 后者对应软件名
		- 格式并非绝对，一具体Docker Registry服务为准
	- ## 公开Dockers Registry
		- 开放给用户使用，允许用户管理镜像的Registry服务
		- 允许用户免费上传和下载公开镜像，可能提供收费服务供用户管理私有镜像
		- 典型例子包括：
			- **Docker Hub**，也是docker的官方服务，且为默认Registry
			- **Quay.io**，Red Hat所属
			- **Google Container Registry**，google所属
			- **ghcr.io**，github所属
		- 在国内使用建议使用国内厂商提供的镜像服务**Registry Mirror**
		- 某些国内厂商也有自己的公开Registry服务
	- ## 私有Docker Registry
		- 用户可以在本地搭建私有Docker Registry
		- Docker官方提供Docker Registry镜像，可以直接启动做为私有Registry服务
			- 此开源镜像只是提供Docker Registry API的服务段实现，足以支持docker命令，但不包含GUI，镜像维护，用户管理，访问控制等高级功能
			- 某些第三方软件不仅实现了基础API，还提供一些更高级功能，如Harbor和Sonatype Nexus