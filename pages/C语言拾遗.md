- # 关键字
	- **static**
		- 如果是**全局函数或变量**：
			- 被该关键词修饰的声明仅在当前文件有效
			- 原则：如果一个函数可以是static的（不在其他地方被引用），那么就一定要static
				- 可以最大限度地避免冲突
		- 如果在**类中**使用static关键字则表示是所有该类共有的成员
		- 如果是**局部**静态变量
			- 表示该变量脱离当前作用域后仍然保持值
			- 再一次进入该函数或**该作用域**时，该变量的值不会再被初始化，而是保留之前的值
			- 例如，记录某一个函数的调用次数，可以在该函数中设置一个局部静态的计数器
			- 在c中只能使用常数来初始化静态变量，不能用某个函数的返回值初始化静态变量
				- 但是在C++中可以
		- 结构体中不应当有单独的静态成员
			- 结构体中的所有成员应该在同一个内存段，因为c中结构体的地址计算就是通过启示地址加上便宜来计算成员地址的
			- 如果个别成员被移到了数据段，将会破坏这一规则或则会将整个结构转化到数据段(?)
	- **inline**
		- 内联函数
		- 告诉编译器对于该函数地调用应该越快越好
		- 不同的编译器实现在处理inline时会有所不同
	- **extern**
		- 表示外部链接，即该符号的定义在别处
		- 对于变量来说，声明即定义
		- 使用extern表示该变量只是声明
		- 实际extern变量的定义不需要加extern 关键字
		- ```
		  //fileA.cpp
		  int i = 1;         //声明并定义全局变量i
		  //fileB.cpp
		  extern int i;    //声明i，链接全局变量
		  //fileC.cpp
		  extern int i = 2;        //错误，多重定义
		  int i;                    //错误，这是一个定义，导致多重定义
		  main()
		  {
		    extern int i;        //正确
		    int i = 5;            //正确，新的局部变量i;
		  }
		  ```
	- **volatile**
		- 表示其修饰的变量是及其易变的，告诉编译器不要对设计该变量的语句做优化，每次都要去内存中读取该变量的最新值
		- 改变可能来自其他线程，也可能来自外部系统
- # 概念
	- **Translation Unit**
		- 指最终输入到c或c++实际编译器中的文件，针对该文件会有一个对应的.o文件生成
		- 一般来说就是经过了预处理的源文件
		- 在该文件中所有的include，宏都被展开，所偶的``#ifndef``代码块都被处理
	- **异常向量表**
		- ARM种的异常向量表是从地址0x0处开始的一段连续内存空间
		- 存储了七种异常的处理程序地址
		- 每种异常处理占一个指令长度
		- 0x0处是reset异常处理需要跳转的地址
		- 0x1c处是FIQ，因为安排在这里可以直接储存处理程序而不会干扰后面存储的处理向量
	- **可重入(re-entrant)函数**
		- 即若某一函数在执行时被中断，然后另一个线程再次从头执行该函数还能够保证得到的结果符合预期，则该函数是可重入的。
			- 既可以同时被多个线程调用执行的函数
		- 应该满足：
			- 不含有静态或全局非常量
			- 不能返回静态或全局非常亮数据的地址
			- 只能处理由调用者提供的数据
			- 不能依赖于但是离模式的资源锁（?）
			- 调用的函数也必须是可重入的
			- 如果一定要使用全局或静态变量，那么在使用过程中应该有一定的保护措施（如关中断）
		- 相反的便是**不可重入函数**
		- 中断处理程序要求是可重入的
- # 杂项
	- ## 为什么要在头文件中声明，在源文件中定义
		- c是**[[$red]]==使用前声明==**的，意味着哪怕一个函数或变量在别的文件中已经定义，在零一文件中使用前也要先声明，告诉编译器去实际定义处寻找高函数
		- 因此将声明置于头文件中可以方便其他文件地引用
			- 如果一个函数需要在很多地方都用到，写进头文件里就能避免在各个文件中使用前都先写一行声明代码
	- ## 头文件中可以放哪些内容
		- 一般来说头文件中应该只有**变量和函数的****[[$red]]==声明==**，没有定义，因为放入声明在多个文件引用同一个头文件时会导致重复定义错误
		- 一下三种类型可以在头文件中定义：
			- **const** 常量
				- const常量默认没有extern属性，因此只在本文件有效，不会造成重复定义
			- **内联函数**
				- 因为内联函数是在预处理阶段就杯展开，因此不会进入链接阶段
				- 内联函数可以被定义多次，只要在一个cpp文件中只有一次定义，且所有文件中的同名同参数内联函数定义都相同，便能通过编译
			- **class**
				- 可以直接在类中定义数据和函数成员
				- 但是static的数据和函数成员只能声明，不能定义
- # 内存
	- 各种变量的其实存储空间的起始值是由**连接器linker**来决定的，可以手动指定数据段的启示值和栈顶的起始值
	- 全局变量在头，栈在尾，堆在中间（?）
	- ## 全局和静态变量
		- [[$blue]]==对于程序中给出初始值需要进行初始化的变量：==
			- 全局和静态变量的分配和初始化不再使用指令初始化的方式，因为这样可能浪费大量的指令
			- 直接编译为一大堆数据放在程序的数据段中
			- 拷贝到内存中执行时，也会将这些数据拷贝到内存中，相当于是程序在载入时就完成了初始化
				- 所以看不到初始化的汇编语句
			- 连接器会事先将这些变量存储的基地址放入代码段的某个地方
				- 通过读取代码段中存好的基地址和偏移量便可获取变量真正的地址，节省了很多代码段的指令存储开销
		- [[$blue]]==对于仅仅声明但没有给出初始值或初始值为0的变量==
			- 由于全局和静态变量在载入时就需要分配空间，对于给出初始化值得变量可以用copy简单处理，而没有给出初始化值得变量就只能先用0占位
			- 使用0占位的变量，分配在ZI段里(个人感觉可以看作数据段的一个特殊部分)
			- 这就是[[$red]]==**为什么静态和全局变量哪怕不给初始值也会初始化为0，而局部变量若不初始化则会是随机值**==
				- 因为**内存分配和初始化的方式完全不相同！**
				- 全局和静态变量**存放与数据段**，这注定了它们必须要在程序载入时就分配空间和初始化，因此未初始化的变量会用0去占位
				- 局部变量**在栈中**分配空间，通过加减sp的方式来实现释放和分配，因此若不提供初始化值，则很有可能占据了之前其他变量使用过又释放的内存地址，所以值是随机的
	- ## 栈
		- C语言中的局部变量是存储在栈里的
		- 栈的地址是向下生长的，即从高地址向低地址生长
		- **为什么栈要向下生长？**
			- 一般来说，静态的或者全局变量从内存的低地址开始储存
			- 那么为了不和这些静态和全局数据冲突，栈的其实地址一般从内存最高地址开始向下存储数据
		- **为什么局部变量要分配在栈里？**
			- 因为在c编译为汇编程序之后，对于返回地址是直接推入栈中保存
			- 因此局部变量保存在内存中时，自然而然地可以将其空间分配在栈中
				- 这样到函数执行完毕需要返回时，直接一直出栈到保存的返回地址就可以方便地清除分配给变量的空间
		- ### 栈的分配
			- 在分配局部变量时，编译器会选择多种方式分配栈空间
			- 返回地址也是保存在栈中的，保存返回地址会直接使用**push lr 指令(在ARM下)**，将lr的的值保存进栈中
				- push指令会先将**栈顶指针(sp)**减4然后再将内容保存到sp地址处
			- 如果需要分配大块连续空间，编译器会直接通过将sp减去相应长度的方式分配内存
			- 一般会在分配内存之后再通过内存store语句进行初始化
	- ## 堆
		- 堆是一块程序员可以在运行时自由分配的**空闲内存**空间
		- 使用malloc和free来管理
		- 一般来说程序内存空间中的所有未使用空间都可以是堆（出去栈的最大大小）
		- 甚至可以事先定义一个很大的未使用数组，占据数据段中的一些空间作为堆，然后自己些malloc函数和free函数来管理这个空间