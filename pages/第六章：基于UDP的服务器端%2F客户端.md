- UDP的特性和邮政系统十分相似
- UDP相较于TCP，**牺牲了可靠特性换取了极高的性能**，无状态，没有流控制
- ![image.png](../assets/image_1682605584952_0.png)
- UDP非常合适用于传递实时多媒体数据，因为少数数据的丢失并不会对多媒体数据产生太大影响
- UDP**并非总是慢于**TCP，一般来说TCP比UDP慢基于以下两点：
	- 收发数据前后进行的连接设置和清除过程
	- 收发数据过程中为保证可靠性而添加的流控制
- 收发数据量少且频繁连接时，UDP比TCP高效
- # 实现基于UDP的服务器端/客户端
	- UDP不需要连接，因此不存在listen和accept函数的调用
	- 一个UDP套接字就可以和多台主机通信，类似于邮筒
	- ## 基于UDP的数据IO函数
		- sendto
			- **头文件**：``<sys/socket.h>``
			- **参数**：``int sock, void* buff, size_t nbytes, int flags, struct sockaddr* to, socklen_t addrlen``
			- **返回值**：成功返回传输字节数，失败返回-1
		- recvfrom
			- **参数**：``int sock, void* buf, size_t nbytes, int flags, struct sockaddr* from, socklen_t *addrlen``
			- **返回值**：成功返回接受字节数，失败返回-1
	- ## 基于UDP的echo服务器/客户端
		- 由于不存在请求连接和受理过程，因此无法也不用取法传统意义上的服务器端和客户端，只要是负责提供服务的一方就可以成为服务器端
	- ## UDP客户端套接字的地址分配
		- 在调用send函数时，自动绑定程序自身sock所使用的地址和端口
- # UDP的数据传输特性和调用connect函数
	- 和TCP不同，UDP的数据是有边界的，意味着在UDP种，**调用IO**函数的次数很重要
		- 发送函数和接受函数的调用次数必须保持完全一致才能保证接受到全部发送的数据
	- ## 已连接(connected)UDP套接字和未连接(unconnected)UDP套接字
		- 不调用connect函数可以直接向某个地址发送UDP数据，每一次调用sendto函数会经历如下阶段
			- 向UDP套接字**注册目标IP和端口号**
			- 传输数据
			- 删除UDP套接字中注册的目标地址信息
		- 如果不用connect，则每次发送数据都需要重复以上三个阶段
	- 调用connect可以固定注册目标地址信息，每次调用sendto时不会再重复以上三阶段，且此时UDP套接字变为**已连接套接字**，可以提升性能
		- 已连接的套接字的[[$red]]==**recvfrom函数会变成非阻塞的！**==
	- 已连接套接字不仅可以使用sendto，recvfrom等函数(地址指针和地址长度指针传入NULL，地址长度传入0)，**还可以使用read和write**
- # 基于windows的实现
	- windows下的sendto函数和recvfrom函数和linux下的对应函数基本没有区别
	-