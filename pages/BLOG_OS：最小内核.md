- # 引导启动
	- 直接上手编写一个引导程序并不简单，也不明智
		- 需要用到汇编语言
		- 建议直接使用相关工具，如bootimage
	- ## 电脑启动过程
		- 主板ROM内存**固件(firmware)被加载运行**，进行：
			- **加电自检**(Power-On Self-Test, POST)
			- **可用内存(Available RAM)检测**
			- **CPU和其他硬件预加载**
			- 寻找**可引导存储介质(Bootable disk)**
			- 引导启动**内核(Kernel)**
		- X86架构支持两种**固件标准**
			- **BIOS**(Basic Input/Output System)
				- 陈旧过时，但是实现简单
				- 1980年代后的素有X86设备都支持
			- **UEFI**(Unified Extensible Firmware Interface)
				- 更现代化，功能更全面
				- 开发和构建更复杂
		- ### BIOS启动过程
			- BIOS固件完成加电自检，初始化硬件之后，将寻找一个可引导存储介质
				- 如果找到，将控制权移交给**引导程序(bootloader)**
				- 引导程序一般存储在存储介质开头的，**512字节长度**的程序片段
			- 由于大多数引导程序都大于512字节，引导程序将被**切分为两段**
				- **第一阶段引导(First Stage Bootloader)**
					- 长度不超过512字节
					- 存储在介质开头
					- 优先启动
					- 负责加载第二段引导
				- **第二阶段引导(Second Stage Bootloader)**
					- 长度较长
					- 存储在其他位置
			- 引导程序一般需要完成：
				- 决定内核位置，将内核**加载到内存**
				- 将CPU从16位**实模式(Real Mode)**切换到32位**保护模式(Protected Mode)**，并最终切换到**64位长模式(Long Mode)**
					- 实模式是为了兼容老旧的BIOS
					- 只有在长模式下，所有的64位寄存器和整个**主内存**才能被访问
				- 从BIOS处查询特定的信息，并传递到内核
					- 例如查询和传递**内存映射表**(Memory Map)
	- ## Multiboot标准
		- 为了避免某个操作系统都实现一边自己的引导程序，自由软件寂静会在1995年颁布了一个**开源引导程序标准**：Multiboot
		- 此标准定义了操作系统和引导程序之间的**统一接口**
		- 任何适配此标准的引导程序都能加载适配了此标准的操作系统
		- **GNU GRUB**是Multiboot的一个可参考实现，也是linux的引导程序之一
		- 在内核文件开头插入**Multiboot header**数据片段即可适配，但存在很多问题
		-