- 补充： [[C++中的memory order]]
- 补充：[[The Denotational Semantics of Programming Languages]]
- # 背景
	- ## 弱内存模型
		- [[$blue]]==Weak/slack memory model==
		- 为了提高并发程序的执行效率而提出
		- 各个模型得弱化行为
			- TSO：每一个线程拥有一个储存缓冲区
			- PSO：每一个线程中得每一个内存位置拥有一个储存缓冲区
			- ARMv8弱内存模型：线程内前瞻执行，乱序执行和储存缓冲区
			- C++11弱内存模型：Promise，时间戳以及线程试图概念的引入
		- ### TSO 弱内存
			- Total Store order
			- 应用在x86和sparc中
			- store-load顺序(在某一内存地址上)被破坏，但是其余三种顺序仍然被保持，会维护两个读（写）操作之间的顺序
			- 这一放松打破了程序执行的顺序一致性，在并发程序执行时，会出现一些在顺序一致性下不会出现的结果
		- ### PSO 弱内存
			- Partial Store Order
			- 在TSO的基础上进一步放松对于内存操作之间顺序的限制
			- #### 内存屏障
				- **全屏障(full fence)**
					- 必须先把之前内存操作的结果迁移到共享内存中才能进行之后的内存操作
				- **store-store fence**
					- 两个写内存操作之间，必须前一个写迁移到功效内存中之后才能进行下一步内存操作
		- ### ARMv8弱内存模型
			- 早期满足非多副本原子性(non Multi-Copy Atomic, nMCA)
			- 由于验证和实现成本问题，修改为满足多副本原子性（MCA）
				- MCA：当一个线程对某一其他线程可见时，它要对其他所有线程可见。
			- **单线程中可能出现的打破SC的情况**
				- 当两条语句之间没有依赖之时就会放宽两条语句之间执行关系的约束
					- 具体的，假设有两条语句``x:=e;y:=f``
					- 若：
						- 变量x和y不相同
						- x没有出现在表达式f中
						- 表达式e中不包含变量y
						- 表达式e和f没有读取相同的全局变量
					- 则可以说两条语句之间没有依赖关系
				- 在**前瞻执行**时也会打破本有的执行顺序，分支执行在两种情况下会发生
					- 当分支指令是一条赋值语句``x:=e``时：
						- x是局部变量
						- e和分支判断语句h不会读取相同的全局变量
						- x不在h中自由出现
			- **并发执行**时，由于单线程中可能出现的乱序优化，可能会出现在SC和TSO模型下都不会出现的行为
		- ### C++11弱内存模型
		  collapsed:: true
			- 通常被定义成公理内存模型
			- 会将任意程序的可能执行结果形式化表达成内存访问事件图(Graphs of Memory Access Events)
				- 表达需要遵循一系列的公理
			- C++弱内存模型引入了多种内存顺序，本文关注两种内存顺序
				- **松弛内存顺序(Relaxed Memory Ordering)**
					- 最弱的内存顺序，不会给沦胥执行增加额外的约束条件，亦不涉及任何同步信息
				- **释放/获取内存顺序(Release/Acquire Memory Ordering)**
					- 为线程之间引入了轻量级的线程间同步关系
					- Acquire表示读之后的内存语句不能重排到acquire之前，可以用在load-store，load-load顺序中
					- Release表示写之前的内存语句不能重拍到release之后，可以用在store-load，store-store顺序中
			- #### Relaxed Access(松弛访问)
				- 对于某一个线程T来说，其内存视图是由T中所有出现过的内存位置的时间戳构成的
				- 用于确定内存访问上的正确语义
				- 一个例子，见论文正文15页
				- **松弛原子更新操作(relaxed atomic update)**是对同一内存位置的一对访问操作
					- 包括：读后改(Read-Modify-Write)，比较交换(Compare-and-swap)，取后加(Fetch-and-add)
					- 在promise语义中，需要做出的操作无非是将时间戳更换为时间段，本质上没有区别[[$red]]==(?)==
			- #### Release-acquire access
				- C++11通过内存屏障指令实现线程间的同步操作
	- ## 形式语义学
		- ### 操作语义
			- 完整描述程序执行过程中可以采取的每一个执行步骤
			- 聚焦于程序**如何(how)**运行
			- 补充： [[小步操作语义和大步操作语义]]
		- ### 指称语义
			- 指称语义是指一个程序**做了什么**
			- 指称语义的优势在于：
				- 可以在没有真实地执行程序的前提下，预测每个程序的行为
				- 基于数学理论，可以对程序进行推导
					- 例如证明一个程序是否和另外一个程序等价
		- ### 轨迹语义
			- 轨迹(trace)是一条记录该进程到某时刻为止参与行为的符号的有限序列
		- ### 代数语义
			- Algebraic Sematics
			- 不关心一个程序的含义，而是如果两个写法不同的程序有着相同的内涵，则它们可以从代数表达上形成等式关系
			- 代数等势还可以看作是从左到右的重写规则
	- ## 统一理论
		- Unifying Theories of Programming
- # TSO 弱内存模型的形式语义
	- ## TSO的轨迹语义模型
		- ### 一个简单的命令式程序语言
			- 用于帮助描述TSO弱内存模型下的各种程序
			- ![image.png](../assets/image_1669022216592_0.png)
			- v表示实数，e是在实数上的表达式，h是布尔表达式，p是程序，fence是全屏障指令，被隔开的两个内存访问操作不能乱序执行
		- ### 轨迹语义
			- 一个轨迹是一个**快照**的序列
				- 快照的形式为：(id,cont,oflag,eflag)
					- id表示一条可能会带来数据状态变化的程序语句的唯一标识
					- cont表示程序语句带来的数据状态变化，有两种形式
						- (var,val)，表示变量var的值为val
						- fence，表示全屏障指令
					- oflag用于区分不同类型的操作
						- 0，表示全屏障指令
						- 1，表示写入储存缓冲区，针对全局变量
						- 2，表示出队并写入内存，针对全局变量
						- 3，表示写入寄存器，针对局部变量
					- eflag用于表示某一操作是由该线程完成还是由环境线程完成。
						- 1表示是由线程本身操作完成
						- 0表示由环境完成
			- 引入一个函数$\pi_i$，表示从某一快照中获取第i个元素
				- 例：$\pi_1(id,cont,oflag,eflag)=id$
			- 如果cont的形式是(var,val)，则可以双重调用$\pi_i$来获取相应的值
				- 例：$\pi_1(\pi_2(id,cont,oflag,eflag))=var$
			- **traces(P)**表示程序P的所有可能的轨迹集合
			- **sb(P)**表示程序P的语句顺序
				- 可以用于检查穿插后的轨迹刻画是否符合程序规范
			- sb序列中的每一个元素的形式为(id, cont)含义和trace中的含义相同
				- sb只包含程序语句，而trace在实际操作中一条赋值语句可能会被拆分为多条trace(一条写入store buffer，一条写入内存)
	- ## TSO的轨迹语义
	  collapsed:: true
		- ### 局部变量赋值语句的轨迹语义
			- 局部变量被直接写入到寄存器中
			- 通过将oflag置为3来表达
			- 线程堆内存的[[$blue]]==感知==来源于**[[$red]]==对过往trace中所有快照的扫描==**
		- ### fence的轨迹语义
			- ![image.png](../assets/image_1669045376941_0.png)
		- ### 全局变量赋值语句的轨迹语义
			- 对全局变量的赋值语句会被分解为两个操作
				- 将值写入本线程的储存缓冲区中
				- 在将来的某一时刻将值从store buffer迁移到共享内存中
				- [[$red]]==这两个操作的顺寻是固定不变的==，一定要先到store buffer中才能写入内存
			- ![image.png](../assets/image_1669046539083_0.png)
			- **源于同一条语句的写入store buffer和写入内存操作拥有同样的ID**
			- ![image.png](../assets/image_1669051888427_0.png)
		- ### 顺序组合的轨迹语义
			- 能够体现**线程内**的乱序执行
			- 分为两个步骤
				- 对进行顺序组合人操作的两个线程的轨迹s和t进行穿插操作
					- 函数inleave(s,t,pc)表示对两条轨迹进行穿插操作
						- pc用于记录顺序组合过程中每条程序语句的出现次序，总是从1开始计数
						- ![image.png](../assets/image_1669106031374_0.png){:height 63, :width 399}
						- ![image.png](../assets/image_1669106798071_0.png){:height 39, :width 419}
							- $inleave_l,inleave_r$分别表示将s的第一个快照进行穿插和将t的第一个快照取出进行穿插
				- 运用能够描述程序顺序和内存改变顺序的po和mo函数提出不符合程序规范所规定行为的轨迹
					- 在包含fence的语句上做简单的上文定义的穿插操作显然会出现一些违反规定的trace
					- 因此使用相应的函数去除掉这些不合规的操作
					- $po$函数用于描述语句之间的程序顺序
						- 输入为一条trace，输出为(id,cont)键值对序列
						- 针对一个快照的oflag进行筛选
							- 返回所有oflag为0,1,3的快照对应的键值对
					- $mo$函数用于描述程序在共享内存上的更改次序
						- 只记录写入内存操作，全屏障指令
			- 整体上顺序组合$P;Q$的语义被分四个步骤定义
				- 选择程序P的一条trace s和Q的一条trace t，对其进行穿插操作
				- 程序P语句出现的次序记录为$sb_1$，程序Q语句出现的次序记录为$sb_2$
				- 对于一条穿插后的轨迹u，检查po和mo作用在它上面的结果是否都是$sb_1+sb_2$的子序列
					- 若检查不通过，意味着该trace不符合规定们需要删除
				- 如果P和Q的所有轨迹都穿插完成，并且穿插后的轨迹都通过了检查，那么得到顺序程序$P;Q$的轨迹语义
		- ### 条件语句的轨迹语义
		- ![image.png](../assets/image_1669125712344_0.png)
		- ### 循环语句的轨迹语义
			- 使用不动点理论定义
		- ### 并发程序的轨迹语义
			- #### 函数merge
				- 通过在并发程序的各自的trace上进行merge操作获得并发之后的最终trace
					- ![image.png](../assets/image_1669129738146_0.png){:height 259, :width 686}
					- $M_3(seq_1,seq_2,pc) =_{df}hd(seq_1)^\wedge Merge(tl(se1_1),tl(se1_2),pc)$
					- $M_1,M_2$函数的作用类似于穿插操作中的$inleave_l,inleave_r$函数，主要是为了特殊处理写入store buffer和写入内存操作之间id必须一致的问题
					- ![image.png](../assets/image_1669913939999_0.png)
			- 在定义了merge操作的基础上，给出并发组合的最终轨迹语义
			- ![image.png](../assets/image_1669208501523_0.png)
				- s是P的环境产生的trace，t是Q的环境产生的trace，$\pi^*_4(s)\in 0^*,\pi_4^*(t)\in 0^*$
					- 这意味着在线程执行完成之后页允许环境做任意多数目的操作
			- #### 函数generate
				- 引入函数$generate(tr,pc)$来从程序的一条trace中生成一条sb序列
				- ![image.png](../assets/image_1669210614127_0.png){:height 167, :width 654}
				- 相当于去掉所有环境和写入内存语句的操作很急
			- 并发的sb定义为：
				- ![image.png](../assets/image_1669210709590_0.png)
	- ## TSO的代数语义
		- TSO弱内存模型下的程序的性质往往被用代数规则描述
		- ### guarded choice
			- $h\&(act,tid,idx)$
				- h是一个布尔条件
				- act可以是写入store buffer，写入寄存器，写入内存，也可以是全屏障指令
				- tid记录操作线程的id
					- 用一个树形的方式标记一个线程的tid
					- ![image.png](../assets/image_1669212290927_0.png){:height 189, :width 254}
					- 上图中A和B的tid分别为$<1,1>,<1,2>$
				- idx用于标识一个动作在顺序程序中的位置信息
					- 也用于区分一个动作是否为向内存写入的动作，为2表示是，为1表示不是
			- 卫兵选择能够对一个程序的所有执行(包括乱序执行)进行建模
			- 一个卫兵选择的一般形式为：$h_i\&(act_i,tid_i,idx_i)\rightarrow P_i'[q_i]$
				- 如果满足了布尔条件$h_i$，则相应的程序行为就是$(act_i,tid_i,idx_i)\rightarrow P'_i[q_i]$
				- 如果$act_i$是一个写入存储缓冲区的动作，那么$q_i$的形式为$h'_i\&(act'_i,tid_i,idx_i')$
					- $act'_i$是对应的写入内存的迁移操作，且$h'_i$的值也应该为真
				- 如果$act_i$是一个局部变量赋值操作，或全屏障指令，那么$q_i$为$\varepsilon$
				- 当遇到一个if或while，$h_i$用于记录分支判断语句，对应的$act_i$为$\varepsilon$
				- $q_i$可能会和程序$p_i'$中的pattern乱序执行
			- 卫兵选择在TSO若内存模型下主要有**三种类型**
				- ![image.png](../assets/image_1669305004863_0.png)
					- 如果满足条件，可以进行写入store buffer的操作
				- ![image.png](../assets/image_1669305052316_0.png)
					- 包含了写寄存器，全屏障指令和分支判断组件
				- ![image.png](../assets/image_1669305171743_0.png)
					- 将前两种卫兵选择组合起来
		- ### 首规范型
			- 给每一个程序赋予一个规范型，名为**首规范型(Head Normal Form)**
			- 对于局部变量赋值语句，展开第一部之后没剩余部分为空
				- ![image.png](../assets/image_1669306659423_0.png)
				- E表示空程序
			- 全屏障指令fence的首规范型定义类似于局部变量赋值语句
				- ![image.png](../assets/image_1669306707540_0.png)
			- 全局变量赋值语句的首规范型，不同之处在于不是原子操作，会被拆分成两块执行
				- ![image.png](../assets/image_1669370646469_0.png)
			- 用两个条件相反，$act_i$为$\varepsilon$的卫兵选择来生成条件语句的首规范型
				- 由于TSO弱内存模型并不允许判断语句和分支语句之间的乱序执行，使用$\rightarrow$
				- ![image.png](../assets/image_1669448130304_0.png)
			- 循环语句的首规范型类似于条件语句
				- [[$red]]==感觉定义不够详细，并没有给出循环语句进一步展开的方式？==
				- [[$red]]==展开为==$P;HF(\text{while } h \text{ do } P)$是否更合适？
				- [[$red]]==**还是说对于剩余的程序，自动使用HF展开？如果是，那么是否应该在展开规则中显式说明？**==
				- ![image.png](../assets/image_1669448155955_0.png)
			- 顺序组合和并发组合的首规范型可以通过顺序展开规则和并发展开规则得到
		- ### 代数规则
			- #### 顺序展开规则
				- ![image.png](../assets/image_1669448274237_0.png){:height 50, :width 465}
					- 卫兵选择可以后向与顺序组合实现分配律
				- **定义1**：$P'[q];Q =_{def}(P';Q)[q]$
					- 描述了[[$red]]==**乱序执行**==的特性。
					- 当后续的程序Q与程序P'顺序组合时，程序P'之前存在迁移操作的格局q，那么该格局可以作用在整个顺序组合程序P';Q上
					- [[$red]]==**对于布尔表达式，如何求值？使用r()函数？r()函数在格局序列上有定义吗？还是代数语义并不在意布尔表达式的求值，只在生成指称语义时才关心？**==
				- 剩余的顺序展开规则研究可以划分为三步·
					- 首先从程序中提取出第一个格局
						- ![image.png](../assets/image_1669449944418_0.png)
					- 改变后续序列中所有格局的位置信息（被提取格局相对应的迁移操作除外
						- ![image.png](../assets/image_1669450142398_0.png)
						- ![image.png](../assets/image_1669452432980_0.png)
						- $\langle1\rangle^\wedge \text{null=null}$，null表示分支判断格局的idx参数
					- 通过迁移动作和其他动作之间有条件的穿插完成所有可能格局序列的生成
						- 两个动作之间（至少有一个是迁移操作）乱序执行要满足一定条件
							- 两个迁移操作应该按照程序顺序以此执行(store buffer要求先入先出)
							- 如过一个动作和另外一个迁移动作来自同一条程序语句，则应该按顺序执行
							- 当遇到一个全屏障指令，那么指令之前语句中的迁移操作应该优先执行
						- ![image.png](../assets/image_1669464058352_0.png)
						- ![image.png](../assets/image_1669466381950_0.png)
			- #### 并发展开规则
				- ![image.png](../assets/image_1669468467335_0.png)
			- 综上所述，任何优先程序P都可以表现为：
				- ![image.png](../assets/image_1669468717452_0.png)
	- ## TSO的语义连接
	  collapsed:: true
		- 考虑如何从代数语义生成轨迹语义
		- 主要关注有限程序
		- 令$seq = c_1\rightarrow c_2\rightarrow \ldots \rightarrow c_n$，表示给定程序$P$的一条格局序列
		- P是**单线程程序**(不含并发组合)，那么可以通过函数Atraces(seq)获取程序P的轨迹
		- 对于**并发程序**，需要更多的步骤
			- 定义一个函数$M^+(seq)$，该函数能生成相应的trace，分三个步骤
				- 提取每一个单线程程序的格局序列
				- 用Atraces函数得到每个单线程程序的trace
				- 结合Merge函数作用在上一步骤中获取到的各个线程的trace上得到并发组合的traces
			- ![image.png](../assets/image_1669820211089_0.png)
				- ![image.png](../assets/image_1669898859533_0.png){:height 27, :width 303}
				- 函数$sep_1,sep_2$分别负责提取出并发组合操作符|| 左边和右边的格局序列
					- ![image.png](../assets/image_1669820318752_0.png)
					- [[$blue]]==相当于获取了在左边程序视角下的格局序列==(具体操作就是若tid开头是1则去掉一个1，视为该线程自己的操作，如果为2则替换为λ，视作环境操作，如果本来就是λ，则不需处理)，两个格局序列[[$blue]]==又都会被==$M^+$函数处理一次变为trace序列的集合
					- 然后在这些trace集合的基础上做merge操作
					- ![image.png](../assets/image_1669886816719_0.png)
			- 函数$DAtraces(seq,pc,tb)$用于**从单线程程序格局序列生成traces**
				- 如果首条格局的判断条件不成立，那么这一条格局序列无法执行，对应的trace为$\emptyset$
				- 如果首条格局的判断条件为true，但是动作act为$\varepsilon$(空动作？)，则生成的trace为{$\varepsilon$}
				- 否则，从格局hd(seq)生成的trace以形式$\{s^\wedge \langle(id,cont,oflag,eflag)\rangle\ \ |\pi_4^*(s)\in 0^*\}$的方式呈现，$s$是环境产生的traces，其余参数的生成遵循以下规则
					- cont可以从动作act获取，[[$red]]==**并发程序可以直接使用叶子程序获取的值读函数r(_)**==
					- oflag根据对应的动作是fence,<x=3>,x=e或a=e分别赋值为0,1,2,3
					- 如果一个格局的tid为$\lambda$，eflag为1，否则为0，[[$red]]==Atrace函数之作用在单线程的格局上(tid均为λ)，这一条规则是否多余？==
				- ![image.png](../assets/image_1669905188665_0.png)
					- $tb_i+=_\text{def}tb_i\Leftarrow(len(\pi_3(hd(seq))),pc_i)$
- # ARMv8弱内存模型的形式语义
	- ## ARMv8 轨迹语义模型
		- 用于描述程序的**语言**
			- ![image.png](../assets/image_1679300438614_0.png)
			- fence是**内存屏障语句**，用于**保证**被其分隔开的内存访问之间的绝对次序
			- cfence是**控制屏障(control fence)**，用于**避免前瞻执行**
		- ### 轨迹结构
			- **快照(snap)**格式：$(cont, oflag, eflag)$
			- **cont**
				- 由$var, val$键值对构成，也可以用于标记**分支判断语句(h)，全屏障(fence)，控制屏障(cfence)**
			- **oflag**
				- 用于区分不同类型的动作
				- ![image.png](../assets/image_1679304656909_0.png)
				- $cont$为键值对时$oflag$为1或2或3
			- **eflag**
				- 用于区分动作对于当前操作的线程
				- 1表示为当前线程自身的操作
				- 0表示为其他线程的操作
		- ### 局部变量赋值语句的轨迹语义
			- ![image.png](../assets/image_1679305824685_0.png){:height 34, :width 459}
			- s是**环境操作**(其他所有线程的可能操作)
			- r()是读值操作，和TSO语义模型的读操作实现细节有差异([[$red]]==**后续问问师姐差异在哪里**==)
			- **全局屏障**指令和**控制屏障**指令的轨迹语义和局部变量赋值(写入寄存器)的语义类似：
				- ![image.png](../assets/image_1679306337713_0.png){:height 74, :width 514}
		- ### 全局变量赋值语句的轨迹语义
			- ![image.png](../assets/image_1679306640346_0.png){:height 73, :width 537}
			- 分为两个步骤：
				- 将值写入对应的储存缓冲区
				- 在将来某一时刻将该值从储存缓冲区迁移到共享内存中
			- 两步之间允许若干其他线程的操作
		- ### 条件判断语句的轨迹语义
			- 需要考虑前瞻执行
			- 需要**检查一个语句能否被前瞻执行**
				- 引入函数：$Nodepd_1(snap\_b,snap\_a)$
					- 用于检查**条件判断语句和其语句**快照(上文定义的组成轨迹的三元组)之间的依赖关系
					- snap_a为一个**赋值语句的快照**，snap_b为一个**条件判断语句的快照**
						- 后者一般以(h,0,1)的形式出现
					- snap_a中的被赋值变量不能是全局变量，因为对全局变量的操作无法撤回[[$red]]==(?)==
					- 符号$dom(\pi_1(snap\_b))$记录条件判断语句中所有变量集合
						- snap_a中**被赋值的变量不能出现在上述集合中**
					- 对于snap_a中读取变量的集合和snap_b中变量的集合**不存在交集**
						- 前者可表示为$dom(\pi_2(\pi_1(snap\_a))$
						- 后者可表示为$dom(\pi_1(snap\_b))$
					- 形式化定义为：
						- ![image.png](../assets/image_1679314925262_0.png)
						- **Globals**为**所有全局变量集合**
						- dom()表示在参数中出现的所有变量集合[[$red]]==(?)==
						- 三个公式(4.1,4.2,4.3)分别代表前文所述的三个性质
				- 引入函数：$Nodepd_2(snap\_b_1,snap\_b_2)$
					- 用于检查**嵌套条件语句之间**的依赖关系
					- 两个嵌套的条件判断语句**没有读取相同的全局变量**，则其之间不存在依赖关系
					- 形式化定义为：
						- ![image.png](../assets/image_1679317831001_0.png){:height 77, :width 561}
			- 一个条件判断语句h，其轨迹语义表示为$traces(h)=_{df}\{s\hat{\ }\langle snap\_b\rangle\}$
				- s是其他线程的任意长度的操作，$\pi^*_3(s)\in 0^*$
			- 所以某一分支语句h的轨迹和其某一分支所有指令构成的轨迹t(包含所有可能穿插结果)表达为：
				- ![image.png](../assets/image_1679319932456_0.png)
				- ![image.png](../assets/image_1679551620760_0.png)
				- 即，要么分支判断语句的trace先做一步，要么在没有冲突的情况下，代表分支中操作的trace先做一步
			- 条件语句的最终形式化定义为
				- ![image.png](../assets/image_1679552964452_0.png){:height 266, :width 656}
		- ### while循环的轨迹语义
			- 和TSO类似，使用不动点理论定义
			- ![image.png](../assets/image_1679555287431_0.png){:height 132, :width 491}
			- 符号$II, STOP$仅用于while轨迹语义的定义
		- ### 顺序组合的轨迹语义
		  collapsed:: true
			- #### 赋值语句之间依赖关系判断
				- 如果两个赋值语句(对应的快照分别为$snap\_a_1,snap\_a_2$x)之间不存在依赖关系，需要满足以下四种限制
					- 两个快照不是对相同的变量进行赋值($\pi_1(\pi_1(snap))$)
					- 后一条语句的被赋值变量不能出现在前一条语句的赋值表达式中(WAR)
					- 后一条语句的读取变量集合不能和前一条语句的被赋值变量有重合(RAW)
					- 两条语句的读取变量集合交集可以不为空，但是重合的变量不能是全局变量，因为环境变量可能随时改变全局变量的值
				- 定义一个函数$NoDepd_3$来完成上述四种情形的检测
					- ![image.png](../assets/image_1679556581969_0.png)
					- 最后一个或条件是针对的WAW，同一个变量的内存迁移需要按照程序顺序
			- #### 赋值语句和条件语句之间依赖关系判断
				- 令一个程序结构为$x:=e; \mathrm{if}\ h\ \text{then }S_1\text{ else }S_2$，赋值语句和快照为$snap\_a$，条件语句h的快照是$snap\_b$
				- 若这两个快照之间可以乱序出现，则需要满足一个函数$No_depd_4$:
					- ![image.png](../assets/image_1679557833571_0.png)
				- 4.8的含义是赋值语句和条件判断不能读取相同的全局变量且x不能出现在条件判断语句中
				- 若赋值语句的快照是在向内存迁移，则根据转发概念，两者之间不会产生依赖
			- #### trace穿插
				- 定义一个$seqcom$函数用于进行前后两条trace之间的有效穿插
				- ![image.png](../assets/image_1679558743550_0.png)
				- 若后一条trace想被提前调度，则要么是其他线程的行为，要么需要满足以下五种情形：
					- ![image.png](../assets/image_1679559089884_0.png)
					- **case 1**，若第一照快照为内存屏障
						- 那么$s$中的所有快照只能是写局部变量(寄存器)且不能读取任何全局变量
						- 意味着在fence之前的所有内存访问，分支判断语句，以及屏障指令都必须先完成
						- ![image.png](../assets/image_1679559779120_0.png)
					- **case 2**，若第一张快照为控制屏障
						- 那么$s$中不能出现任何屏障指令(fence, cfence)和分支判断语句
						- ![image.png](../assets/image_1679559858986_0.png)
					- **case 3**，若第一张快照是全局变量的写(写入缓冲区或内存迁移)
						- 那么$s$中不能有屏障，和分支判断语句，即只能包括赋值语句且不能有依赖关系
						- ![image.png](../assets/image_1679560684413_0.png)
					- **case 4**，若第一张快照是写寄存器
						- 又可细分为两种子情况，$case_4(s,t)=_df case_{4\_1}(s,t)\vee case_{4\_2}(s,t)$
						- 第一种子情况是写寄存器操作会**读取全局变量**，此时$s$中只能出现不和其有依赖关系的分支判断语句和赋值语句
							- ![image.png](../assets/image_1679561818870_0.png)
						- 第二种子情况是**不会读取全局变量**，相比上一种子情况。此子情况允许出现fence
							- ![image.png](../assets/image_1679562614777_0.png)
					- **case 5**，若第一张快照是分支判断语句
						- 则和写寄存器类似，不再次列出
					- 最终的顺序组合轨迹语义：
						- ![image.png](../assets/image_1679563279920_0.png)
		- ### 并发组合的轨迹语义
			- 两个程序P和Q的trace $seq_1,seq_@$是可比较的，当：
				- $\pi_i^*(seq_1)=\pi_i^*(seq_2),i=1,2$
				- i为1时表示构建自相同而数据状态序列，i为2时表示动作类型序列完全一致
			- 任何动作都是由两个进程中的某一个或环境执行的，即$2\not\in\pi_3^*(seq_1)+\pi_3^*(seq_2)$
			- 定义两个trace的合并操作
				- ![image.png](../assets/image_1679918108805_0.png)
			- 定义并发组合的轨迹语义：
				- ![image.png](../assets/image_1679918240173_0.png)
				- [[$red]]==**s和t应该解释一下**==
	- ## ARMv8的代数语义
		- ### 卫兵选择
			- **卫兵组件格式**：$h\&(act,tid,idx)[q]\looparrowright P$
				- h是一个布尔条件
				- act表示从程序语句中提取出来的动作
				- tid表示执行动作的[[$red]]==进程==
				- idx表示某一动作序列在顺序程序中的位置信息，格式为一个键值对$(num,isMem)$
					- num表示执行过程中动作所属语句的语句顺序，在每一个顺序程序内部，语句的顺序从一开始计数
					- isMem用于区分一个动作是不是迁移操作，2表示是，1表示不是
				- [q]是一个对全局变量赋值所引发的后续内存迁移动作
					- 在一个操作序列中，写入store buffer记作$<x=1>$，其对应的内存迁移动作记为$x=1$
			- **卫兵选择格式**：
				- ![image.png](../assets/image_1680007268553_0.png)
			- 每个程序都可以被表达成卫兵选择的形式，在ARMv8若内存模型下，卫兵选择只有如下三种类型
			- ![image.png](../assets/image_1680007324853_0.png)
				- 第一种仅包含全局变量赋值语句组件，当对应的布尔条件满足时，执行写入store buffer的动作
				- 第二种由局部变量赋值语句，屏障指令和条件语句组成
				- 第三种由以上两种组合得到
		- ### 首规范型
			- 每一个程序都可以用首规范型递归展开为卫兵选择
			- **对于全局变量赋值**
				- 一个全局变量赋值语句会被分解为两个动作，写入store buffer和内存迁移
				- ![image.png](../assets/image_1680009176563_0.png)
				- E表示空程序，下同
			- **对于局部变量赋值**
				- ![image.png](../assets/image_1680009210492_0.png)
			- **对于条件语句**
				- ![image.png](../assets/image_1680009543846_0.png)
				- $\varepsilon$说明条件判断语句本身并不会对数据状态做出任何改变
			- **对于循环语句**
				- ![image.png](../assets/image_1680009728587_0.png)
				- 依据不动点理论，其处理类似于条件语句
			- ### 代数规则
				- **顺序规则1**：顺序组合
					- ![image.png](../assets/image_1680010036338_0.png)
				- **顺序规则2**：递归展开
					- ![image.png](../assets/image_1680010554807_0.png)
					- $\hookrightarrow$相较于$\looparrowright$规定了语句之间的程序顺序，但其连接的两个格局之间仍然可能出现乱序执行去。不同箭头的含义如下
					- ![image.png](../assets/image_1680010760474_0.png)
					- ![image.png](../assets/image_1680010801074_0.png)
					- $(\varepsilon)\uparrow1=\varepsilon$
				- **顺序规则3**：调度获取所有格局序列
					- ![image.png](../assets/image_1680012052140_0.png)
					- $cond_i$有很多种情形，和前文中轨迹语义模型下定义的$case_j$相关，针对每一种case都会有一种$cond_i$的定义
				- **并发规则1**：
					- ![image.png](../assets/image_1680012417252_0.png)
					- 左分支在tid前append 1，右分支append 2
	- ## ARMv8 语义连接
		- 对于一个**[[$red]]==有限程序==**生成的有限格局序列$seq = c_1\rightarrow c_2 \rightarrow \ldots \rightarrow c_n$，其轨迹语义可定义为：$Atraces(seq)=_{df}Atraces(c_1)^\wedge Atraces(c_2)^\wedge \ldots ^\wedge Atraces(c_n)$
		- 一个序列中的每一个格局$c_i$表现形式为$h\&(act,tid,idx)$
			- 若$h$值为false，则$Atrace(c_i)=_{df}\phi$，$s^\wedge \phi=s$
			- 若为true，则$Atrace(c_i)=_{df}\{cont,oflag,eflag\}$，$\pi_3^*(s)\in0^*$，表示s是环境产生的轨迹
				- **cont**从对应格局的h和act得到
				- **oflag**从格局首规范型中的act得到
				- **eflag**从进程ID处得到，若ID为$\lambda$，eflag为1，否则为0
		- ### 形式化定义顺序程序由代数语义序列到轨迹语义的转换
			- ![image.png](../assets/image_1680166841620_0.png)
			- 对于并发组合的格局序列到轨迹语义的转换，定义一个$M$函数完成，该函数所作的工作大致分为三个步骤
				- 从序列中提取出每个单线程程序的格局序列
				- 得到这些单线程程序的轨迹语义
				- 运用轨迹语义模型中定义的merge函数
				- ![image.png](../assets/image_1680168463224_0.png)
				- $(\lambda^*\kappa^*)^*$表示得到了某一进程的格局序列，该序列仅包含本进程产生的格局和环境产生的格局
				- $\kappa$由后续函数$sep_1,sep_2$引入
			- $sep_1$负责提取并发操作符$\|$左分支的序列
				- ![image.png](../assets/image_1680169779351_0.png)
				- $\le$ 表示前缀关系
				- 如果一个格局的线程ID前缀为1，依据代数规则，此格局由并发操作符左边的程序生成，移除线程ID前缀
				- 否则用$\kappa$替代格局线程id
			- $sep_2$和$sep_1$互为镜像
				- ![image.png](../assets/image_1680171019278_0.png)
			-