- # 绪论
	- ## 研究现状
		- ### 系统约束的表达
			- 仿真trace分析工具表达系统约束的能力决定了工具的分析能力
			- 一种对于约束的表达方式是各种**时序逻辑(Temporal Logic)**
				- LTL(Linear Temporal Logic)：线性时序逻辑
				- CTL(Computational Tree Logic)：计算树逻辑
				- GIL(Graphic Interval Logic)：图形区间逻辑
				- MTL(Metric Temporal Logic)：计量时序逻辑
				- 本文章认为，这些逻辑语言对时间的概念抽象程度过高，导致无法很好刻画SoC中“实时”property
				- 且时序逻辑语言要求使用者具备相应理论知识才能较为精确地表达系统属性，造成较高门槛
			- 另一种方式为**逻辑约束(Logic Of Constraints, LOC)**
				- 能够为实时系统属性的表达提供更高层次的抽象能力
				- 但LOC[[$red]]==**难以表达因果关系**==，而大多数系统属性都是因果属性
				- 且必须以仿真trace作为输入，不支持实时验证（是一个离线算法？）
		- ### 仿真trace的记录与分析
			- 仿真trace分析工具分为两种运行模式
				- **在线(Online)**
					- 分析工具和模拟器同时运行，实时地对模拟器产生地仿真trace进行分析
				- **离线(Offline)**
					- 模拟器首先运行并产生仿真trace文件，再交由分析工具对该文件进行分析
				- 无论哪种方式，trace都必须以一定格式生成文件保存下来
			- 因为SystemC在片上系统建模中的重要作用，其使用的VCD(Value Change Dump)仿真trace格式也被广泛使用
			- **OTF2(Open Trace Format 2)**也是一种trace文件格式，具有较强的可扩展性
- # 相关理论和技术背景
	- ## 硬件模拟器
		- ### 概述
			- **SimSoC**是一个使用C/C++和SystemC库实现的虚拟原型框架
				- 最初用来对数字电路进行建模
				- 可以通过C++编译器进行编译和运行
				- 逐渐被用于进行系统级的建模
		- ### SimSoC框架
			- ![image.png](../assets/image_1671117470646_0.png){:height 351, :width 510}
			- 通过SystemC/TLM（Transaction Level Modeling, SystemC的一个模块）对硬件模块进行模拟
			- 对片上系统的模拟分为**三部分**
				- 对每个指令执行过程的模拟
					- 图中上半部分表示对指令集的模拟
				- 对系统状态和行为的模拟
					- 对内存的模拟，包括虚拟内存地址到物理地址之间的转换
				- 对系统组件和设备之间通信的模拟
					- 使用虚拟总线来表示不同模块之间的通信
			- 本文使用SimSoC作为Trap的硬件模拟平台
		- ## 时钟约束语言
			- **MARTE(Modeling and Analysis of Real-Time and Embedded)**是UML的一个扩展，用以弥补UML在时间行为上表达能力的不足
			- MARTE定义了定义了**时钟约束语言(Clock Constraint Specification Language，CCSL)**来描述“时间”相关的约束条件
			- 其中，**时钟(Clock)**是一种用来表示时间的数据结构，分为两种
				- **同步时钟**
					- 和物理时间，即真实时间相关
				- **逻辑时钟**
					- 离散逻辑上的时间，用来表示时序关系
					- 对“事件的抽象化描述”
					- 在时间轴上产生一个个**时刻(Tick)**
					- 拥有一个属性，**ID**，用于对不同的逻辑时钟进行区分
					- 属性**时间戳(Timestamp)**用来表示逻辑时钟作用的事件，用以定义时序
			- CCSL中和逻辑时钟相关的语句分为两种
				- **时钟表达式(Clock Expression)**
					- 选取一个或以上的逻辑是中作为输入，并引入一个新的逻辑时钟
					- 如果条件满足，表达式引入的逻辑时钟起效，并产生一个新的时刻
				- **时钟关系式(Clock Relation)**
					- 用于描述两个逻辑时钟之间的时序，作用数量等关系
					- 表示逻辑时钟所在的系统的属性
		- ### 建模框架
			- 基于**EMF(Eclipse Modeling Framework)**
			- **Xtex**是一个文本建模框架，用于**领域特定语言(Domain Specific Language, DSL)**的开发
				- 定义了一套语法规则，用来描述DSL语法
				- [[$red]]==感觉是一个很方便的，可以构建编译器特定语言编译器的工具==
			- TRAP使用Xtex定义了若干DSL语言来结构化仿真trace，描述时间映射和系统属性等
			- 使用了Xtex的三个特性
				- **验证器(Validator)**
				- **代码生成器(Generator)**
				- **Eclipse IDE 支持**
			- ### Xtend 程序设计语言
				- Xtext的开发语言之一
				- 是一种静态强类型语言
	- ## 相关自动机理论
		- **有限自动状态机(FSA)**
		- **有限状态变换器(Finite-State Transducer, FST)**
		- 以上两种状态机都存在状态爆炸的问题
		- **符号有限自动机(Symbolic Finite Automaton, SFA)**和**符号有限变换器(SFT)**分别扩展了FSA和FST，其二者的字母表可以是无限的
		- TRAP使用SFA和SFT构建属性系统的底层自动机模型
		- ## 符号有限自动机(SFA)
			- 符号有限自动机的状态迁移基于**有效逻辑代数**，定义如下：
			- **定义2.4.1：**
				- 有效逻辑代数是一个八元组$A=(D,\Psi,\llbracket\_\rrbracket,\bot,\top,\vee,\wedge,\neg)$
				- D是字母表
				- $\Psi$是使用逻辑连接符构建的**迁移条件集合**
				- 且$\bot,\top\in\Psi$
				- $\llbracket\_\rrbracket:\Psi\rightarrow 2^D$是一个函数，且满足以下条件
					- $\llbracket\bot\rrbracket=\empty$
					- $\llbracket\top\rrbracket=D$
					- $\forall\alpha,\beta\in\Psi,\llbracket\alpha\vee\beta\rrbracket=\llbracket\alpha\rrbracket \cup \llbracket\beta\rrbracket,\llbracket\alpha\wedge\beta\rrbracket=\llbracket\alpha\rrbracket\cap\llbracket\beta\rrbracket$
			- 基于该定义，符号有限自动机可以形式化定义为五元组
			- **定义2.4.2**
				- 符号有限自动机$M=(A,Q,q^0,F,\Delta)$
				- A是有效逻辑代数
				- Q是有限的状态集合
				- $q^0\in Q$是自动机的初始状态
				- $F\subseteq Q$是终止状态集合
				- $\Delta \subseteq Q\times \Psi_A\times Q$是状态迁移集合
			- SFA字母表D中的元素称为字母，由它们构成的有限序列成为字串
			- 给定字串w，其是否可以被一个SFA接受的定义如下
			- **定义2.4.3**
				- 给定字串$w=a_1a_2\ldots a_k$，若$w$被符号有限自动机$M$接受，则当且仅当对于$1\le i\le k$，存在状态迁移$q_{i-1}\rightarrow q_i$，有$q_0=q^0$且$q_k\in F$
		- ### 符号有限变换器
			- 是SFA的变体，不同之处在于，对于给定的输入字串，SFT可以输出一个字串
			- **定义2.4.4**
				- 符号有限变换器$T=(A,Q,q^0,\Delta,F)$
				- A是有效逻辑代数
				- Q是有限的状态集合
				- $q^0\in Q$是自动机的初始状态
				- $\Delta$是集合$Q\times\Psi\Lambda^*\times Q$的有限子集，表示状态迁移集合
					- $\Lambda$是自动机的函数项集合
				- $F\subseteq Q$是终止状态集合
			- SFT的一次状态迁移为$(p,\varphi,f,q)$，或表示为$p\overset{\varphi/f}{\rightarrow}q$
				- f表示自动机的输出，当STF的所有迁移都输出空($\varepsilon$)是，SFT退化为相应的SFA
- # 系统设计
	- 在DSL中定义了四种语言
		- **仿真trace条目描述语言**(Trace Item Specification Language, **TISL**)
			- 定义了模拟器在运行过程中，能够向用户提供的信息
		- **逻辑时钟描述语言**(Logical Clock Specification Language, **LCSL**)
			- 对用户系统中发生的事件进行抽象表示
		- **模拟仿真trace映射语言**（Simulation Trace Mapping Language, **STML**)
			- 定义将一个或多个仿真trace条目映射为一个逻辑时钟时刻的映射规则
		- **仿真trace属性描述语言**(Trace Property Specification Language, **TPSL**)
			- 描述用户系统运行中产生的trace必须满足的系统约束
			- 引用LCSL中定义的逻辑时钟和作用域，以若干条规则的形式对系统的玉树进行描述
	- TRAP的**使用流程**
		- **模拟器开发者**使用TISL定义trace item，对模拟器在仿真过程中提供的信息进行抽象，并使用TRAP生成的代码重新编译模拟器
		- **模拟器使用者**使用LCSL定义逻辑时钟和作用域，规定用户系统的事件和规则的作用范围(何时起效)
		- **模拟器用户**使用STML定义trace item与逻辑是中之间的映射关系，TRAP[[$red]]==生成动态库链接==
		- **模拟器用户**使用TPSL定义系统运行过程中trace需要满足的属性，[[$red]]==TRAP生成部分验证器代码==
		- **模拟器用户**使用TPSL生成的代码编译验证其，运行模拟器和验证其，得到分析结果
	- TRAP工具链包含：
		- 模拟器
		- trace映射库
		- 验证器
	- ## TISL
		- 有模拟器开发者定义
		- 描述仿真过程中，模拟器能够为为使用者提供哪些信息
		- 定义若干trace item，每一个trace item之间包含名字和若干属性，trace item之间可以存在但继承关系
		- 语法和C++十分相似
		- ### 语法
			- 用户须在TISL文件的开头通过generates关键词指定本地文件系统中的一个文件夹来存放TRAP生成代码的放置位置
	- ## LCSL
		- 定义两个基本元素，主要用于TPSL中描述系统约束
			- **作用域**
				- 用于表示TPSL中每条规则在系统运行的什么阶段内有效
				- 对系统运行过程进行分段
			- **逻辑时钟**
				- CCSL中的概念，在TPSL中表示基本事件
				- 每一次作用都产生一个时刻，时刻拥有两个属性
					- 逻辑时钟标识(名称）
					- 时间戳
		- 比TISL的抽象层次更高，将模拟器的底层信息与系统属性隔离，便于表系统约束
		- ### 语法
			- ![image.png](../assets/image_1671373823110_0.png){:height 212, :width 457}
			- 作用域和时钟列表均可为空
		- ## STML
			- 定义TISL中定义的trace item和逻辑时钟的关系
			- 一个逻辑时钟往往由若干个trace条目映射出来，用不同的“**周期**”来区分
			-