- 游戏引擎中的渲染需要做到高度**实时化**(Realtime)
	- 至少要做到30FPS以上才能叫作“**实时**”
- # 渲染管线和计算
	- ![image.png](../assets/image_1712504009484_0.png)
	- 绘制系统实际上是要做大量的运算，包括：
		- ### 光栅化
			- ![image.png](../assets/image_1712504347368_0.png)
		- ### 着色
			- ![image.png](../assets/image_1712504378911_0.png)
		- ### 材质采样
			- ![image.png](../assets/image_1712504432973_0.png)
	- ## 了解GPU
		- ### SIMD和SIMT
			- SIMD(Single Instruction Multiple Data)
				- ![image.png](../assets/image_1712591540984_0.png){:height 193, :width 170}
				- 一条指令，同时执行若干次数据运算
				- 类似于并行的数组计算
			- SIMT(Single Instruction Multiple Threads)
				- 伴随有多线程的SIMD
				- ![image.png](../assets/image_1712591647426_0.png){:height 140, :width 371}
				- GPU就是使用了SIMT思想，其架构中包含大量核心(N卡的CUDA)
		- ### 数据的单项流通
			- CPU和GPU之间通信的代价非常昂贵
			- GPU自带显存用于存储临时数据
			- 在游戏引擎的设计中，一个原则是数据**仅从CPU到GPU单向流通**，且从CPU到GPU之间通信的数据量也应当最小化
		- ### 关注缓存性能
			- cache miss的性能损失远超想象
			- 应该合理组织所需数据在内存中的存储方式，以保证更高的缓存命中概率
		- ### 限制GPU性能的各个方面
			- Memory Bound
			- ALU Bound
			- TMU(Texture Mapping Unit) Bound
			- BW(Bandwidth) Bound
- # 可渲染物体
	- 并不是每一个GO都是可渲染的，更不是每一个GO都应当被渲染
	- 所以引擎一般都会提供和渲染相关的Component，只有拥有这些Component的GO才应当被绘制
	- 目前最常用的用于渲染的component，是**网格(Mesh)**以及绘制网格所需的各种数据(Texture, Material等)
	- ## 可渲染数据
		- 在游戏引擎中，如果想渲染一个东西，那么首先需要存储渲染这些东西所需要的**数据**
		- ### 网格(Mesh)
			- 也就是一般认知中的**模型**
			- ![image.png](../assets/image_1712594055281_0.png){:height 203, :width 390}
			- 网格一般被以**顶点**和**三角形**的方式组织起来
			- 一般Vertex的信息需要直接存储，而三角形的存储方法可能会比较取巧，因为需要节省存储空间和最大化cache性能
				- ![image.png](../assets/image_1712594295146_0.png){:height 363, :width 296}
			- 一种最新的思路是**[[$red]]==Cluster-Based Mesh==**
				- 可以几乎无限细分网格
		- ### 材质(Material)
			- 决定了一个物体的表面观感，主要是定义了物体如何和**光(源)**交互
			- 是游戏画面看起来真实的决定性因素之一
				- 另一方面就是模型(网格)的精细程度
			- 常见的材质模型包括：
				- 最经典的Phong-shading模型
				- PBR(Physically Based Rendering)
				- Subsurface Material
		- ### 纹理(Texture)
			- 纹理实际上可以看作材质的一部分
			- 在phong材质模型中，漫反射的Kd随着物体表面的uv坐标改变，描述这些Kd如何随着这uv变化的数据就是纹理
			- 游戏引擎一般不会直接使用JPG，PNG等图片格式存储纹理，一般会使用基于block的压缩算法去做纹理压缩
				- 在PC上，一般是BC7
				- 在移动端上，一般是ASTC
		- ### 着色器(Shader)
			- 一种很奇怪的渲染数据
			- 首先其本身通过代码写成，一般是GLSL或者别的什么语言。
			- 但是实际上会被编译成一个个二进制数据，和网格，材质等渲染数据放到一起
			- 实际GPU在绘制时，既会载入网格，材质等数据，也会载入编译好的Shader来决定如何渲染这些数据
	- ## 在引擎中渲染物体
		- ### 坐标系(Coordinate System)和变换(Transformation)
			- 模型asset基于自己的局部坐标系(Local Coordinate System)
			- 而引擎最终要做的，是把这些物体绘制到空间坐标当中
			- 这就需要各种变换，具体的变换过程在GAMES101中有讲，此处不做涉及
		- ### 子网格(Submesh)
			- 一个网格可能需要多种材质和纹理，因此在实际渲染时，一个网格可能会被拆分为多个子网格
			- 每个子网格对应自己的材质和纹理
			- ![image.png](../assets/image_1713087343745_0.png){:height 277, :width 532}
		- ### 资源池
			- 每个GO所使用到的材质，纹理等资源如果都在内存中存储一份拷贝，则会导致大量的内存浪费
			- 常用的做法是将资源存入一个池子中，同样的资源(同一份材质，纹理等)仅在内存中存一份，不同的需要渲染的GO仅仅存储所需要用到的渲染资源
			- ![image.png](../assets/image_1713111327779_0.png)
			- 还可以将需要绘制的GO的mesh通过材质排序，使拥有相同材质的mesh在渲染顺序上相邻，如此可以通过局部性原理，优化绘制性能
		- ### GPU Batch Rendering
			- 游戏中存在大量外观相同的重复物体
			- 对于这些物体，GPU支持通过一个draw call绘制多个实例
			- 在Unity中，可以调用``Graphics.DrawMeshInstanced``达到类似的效果
	- ## Visibility Culling
		- 玩家只能看到摄像机世界锥中的物体，对于视野之外的物体，完全可以不用绘制
		- ![image.png](../assets/image_1713112076405_0.png)
		- 而如何判断一个物体是否在视界锥中，需要给物体上一个包围盒来辅助快速判断，常用的包围盒包括：
			- ![image.png](../assets/image_1713112358194_0.png)
		- 再借助四叉树，BVH等加速结构，可以进一步降低culling计算的复杂度
		- ### PVS(Potential Visibility Set)
			- 将环境分为各个节点和portal
				- ![image.png](../assets/image_1713113056606_0.png)
			- 只绘制能看到的节点
				- ![image.png](../assets/image_1713113119449_0.png)
			-