- 游戏引擎中的渲染需要做到高度**实时化**(Realtime)
	- 至少要做到30FPS以上才能叫作“**实时**”
- # 渲染管线和计算
	- ![image.png](../assets/image_1712504009484_0.png)
	- 绘制系统实际上是要做大量的运算，包括：
		- ### 光栅化
			- ![image.png](../assets/image_1712504347368_0.png)
		- ### 着色
			- ![image.png](../assets/image_1712504378911_0.png)
		- ### 材质采样
			- ![image.png](../assets/image_1712504432973_0.png)
	- ## 了解GPU
		- ### SIMD和SIMT
			- SIMD(Single Instruction Multiple Data)
				- ![image.png](../assets/image_1712591540984_0.png){:height 193, :width 170}
				- 一条指令，同时执行若干次数据运算
				- 类似于并行的数组计算
			- SIMT(Single Instruction Multiple Threads)
				- 伴随有多线程的SIMD
				- ![image.png](../assets/image_1712591647426_0.png){:height 140, :width 371}
				- GPU就是使用了SIMT思想，其架构中包含大量核心(N卡的CUDA)
		- ### 数据的单项流通
			- CPU和GPU之间通信的代价非常昂贵
			- GPU自带显存用于存储临时数据
			- 在游戏引擎的设计中，一个原则是数据**仅从CPU到GPU单向流通**，且从CPU到GPU之间通信的数据量也应当最小化
		- ### 关注缓存性能
			- cache miss的性能损失远超想象
			- 应该合理组织所需数据在内存中的存储方式，以保证更高的缓存命中概率
		- ### 限制GPU性能的各个方面
			- Memory Bound
			- ALU Bound
			- TMU(Texture Mapping Unit) Bound
			- BW(Bandwidth) Bound
- # 可渲染物体
	- 并不是每一个GO都是可渲染的，更不是每一个GO都应当被渲染
	- 所以引擎一般都会提供和渲染相关的Component，只有拥有这些Component的GO才应当被绘制
	- 目前最常用的用于渲染的component，是**网格(Mesh)**以及绘制网格所需的各种数据(Texture, Material等)
	- ## 可渲染数据在引擎中的组织结构
		- ![image.png](../assets/image_1712594055281_0.png){:height 203, :width 390}
		- 首先是网格，网格一般被以**顶点**和**三角形**的方式组织起来
		- 一般Vertex的信息需要直接存储，而三角形的存储方法可能会比较取巧，因为需要节省存储空间和最大化cache性能
			- ![image.png](../assets/image_1712594295146_0.png){:height 533, :width 434}
		-