- TODO 阅读LiteNES的代码，尝试优化
- 补充： [[menuconfig简介]]
- 补充： [[地址无关代码简介]]
- 补充： [[c语言的缓冲区]]
- 补充： [[C语言为什么要关闭文件指针]]
- 补充： [[左值和右值]]
- 补充： [[gcc编译过程简介]]
- 补充： [[ELF文件格式和链接过程简介]]
- gcc支持代码块有返回值，返回值位最后的计算操作
	- 不能只有声明语句
- # [[$red]]==问题==
	- ## DIFFTEST
		- 为什么在进行difftest的时候需要传入一个已经执行过的pc和下一个pc？
		- 而且还根据是否跳过了nemu的执行来区别是传入执行过的pc和下一个pc？
		- 在全局的cpu对象中，明明已经记录了当前的pc，为什么还要传入两个pc？
		- [[$red]]==目前是直接用全局cpu对象中的pc去比对ref的pc，暂时没有出现问题==
		- ```
		  src/cpu/cpu-exec.c:47:
		  IFDEF(CONFIG_DIFFTEST, difftest_step(_this->pc, dnpc));
		  ```
	- ## [[$red]]==声卡的实现==
		- 尝试着实现了声卡，能通过audio test
		- 但是仅限于此，播放自定义的音乐和玩马里奥时都不能正常运行，且玩马里奥时性能损耗极大，甚至无法正常显示画面
		- 不知道是实现错误，还是实现的效率过低，无法正常运行
- # 运行时环境
	- 运行时环境很多时候和硬件架构密切相关
	- 为了解耦，降低维护成本，可以抽象出程正确执行所需要的API，硬件层面提供对这些api的支持
		- 这些API可以被封装为库函数
	- ## Abstract machine
		- 一组统一抽象的API，代表了程序运行对于计算机的需求，因此被称为抽象计算机
		- AM是一个向程序提供运行时环境的库
		- AM=TRM+IOE+CTE+VME+MPE
			- TRM：图灵机，最简单的运行时环境，提供基本的计算能力
			- IOE：IO Extension，输入输出扩展，为程序提供输入输出的能力
			- CTE：Context Extension，上下文扩展，提供上下文管理的能力
			- MPE：Multi-processor Extension，多处理器扩展，为程序提供多处理器通信的能力
		- 因此NEMU的开发流程：
			- (在NEMU中)实现硬件功能 -> (在AM中)提供运行时环境 -> (在APP层)运行程序
- # Trace
	- ## 环形buf
		- ### 实现思路
			- 修改nemu对于参数的处理，根据输入的参数确认是否开启环形buff(可选)
			- 增加初始化环形buf的函数(可选)
			- 增加环形buf对象
			- 每次traceanddifftest的时候，将当前指令的内容输入进buff
		- ### 实际实现
			- 没有设置额外的参数，ringbuf的内容直接输出到nemu-log.txt文件的最后位置
			- 由于isa的取值和执行是一并执行的，所以ringbuf没法取到最新的inst的值，记录停留在出错前的一条指令上，解决办法：
				- 将取值和执行分开，增加一个prefetch函数，先将指令的值取到Decode结构体中，完成记录之后再执行
			-
- # Differential Testing
	- 是软件测试中一种常用且有效的方法，通过对比一个有效实现来判断软件的正确性
	- 简称DiffTest
	- 正在开发当中的被测试对象称为**Design Under Test(DUT)**
	- 功能相同但是实现方式不同，用于作为行为参考的对象称为**Reference(REF)**
	- 让上述两个对象接受相同的有定义的输入，观测它们的行为是否不同
- # 输入输出
	- **[[$blue]]==设备是连接计算机和物理世界的桥梁==**
	- CPU需要与设备进行同行来完成某些工作
	- 一般来说，CPU需要与设备进行的通讯行为包括：
		- 输入
		- 输出
		- 控制
	- CPU与设备的接口，一般是通过对设备的一些寄存器进行访问和改写来完成的
		- 设备用于通讯和控制的寄存器往往有编号，CPU通过编号进行访问
		- 设备还可能有一些自己维护的寄存器，这些寄存器往往没有对外的编号，CPU无法直接访问
	- 这些编号就是I/O编址方式，常用的编址方式有两种
	- ## 端口I/O
		- 端口映射(port-mapped I/O)
		- CPU使用专门的I/O指令对设备进行访问
		- 把设备的地址称作**端口号**，在I/O指令中给出端口号，便可以访问某一个设备的寄存器
		- 市面上绝大多数计算机都是IBM PC兼容机
			- IBM PC兼容机对常见设备的端口号有[特殊规定](https://en.wikipedia.org/wiki/Input/output_base_address)
		- x86架构提供了``in``和``out``指令用于访问设备
			- ``in``将设备寄存器中的数据传输到CPU的寄存器中
			- ``out``将CPU寄存器中的数据传送到设备寄存器中
	- ## 内存映射I/O
		- 端口映射I/O导致了设备地址空间大小的固化，不利于后续拓展
			- 后续的计算机必须兼容之前的指令集，只能增添端口而不能修改已有端口
		- 内存映射I/O将一部分物理内存重定向到I/O地址空间当中
			- CPU访问这一部分物理内存时，实际上访问了相应的I/O设备
		- 通过普通的访存指令就可以完成和设备之间的通信
		- 内存映射IO的唯一缺点是被映射到IO地址空间的实际物理地址不再能被直接访问
			- 在现代64位计算机中不再是缺点，物理地址线都有48根，物理地址空间达到256TB，分出部分物理地址空间去做内存映射完全不是问题
		- **RISC架构只提供内存映射IO编址**，相当多的主流设备也支持通过内存映射IO来访问
	- [[$red]]==**输入输出对程序的影响**==也仅仅体现在**输入时会进行一次不能提前确定的状态转移**, 这基本上就是程序眼中输入输出的全部
	- 还有一种直接让设备访问内存的通信方式，叫做**DMA(Direct Memory Access**，DMA能够显著提升性能，不再需要通过CPU寄存器中专，一些复杂设备可能会提供DMA功能(例如显卡)
	- ## 设备
		- NEMU使用SDL库实现设备的模拟
	- ## [[$red]]==实现IOE==
		- IOE个人理解[[$red]]==就是设备驱动==
		- 在NEMU中访问设备经历的抽象层：KLIB定义的设备访问宏->IOE(平台无关)->平台相关驱动->NEMU设备
		- ### 对于设备的访问如何实现？
			- **在NEMU层面**
				- NEMU作为一个虚拟器，模拟了CPU和设备的交互
				- 将不同的地址空间和相应的设备寄存器之间做了映射
				- 给每个设备都划分了一定的CPU可以访问的内存空间，这个内存空间可以直接用相应的访存语句来访问，因此对于设备空间的访问，对于CPU来说是**无感的**
				- 每个设备的行为由一个handler来定义
				- 设备内存空间的值会在访存语句中被写入对应地址或者返回给对应的NEMU寄存器
			- **在AM层面**
				- 个人理解，[[$red]]==AM就是一个简易的操作系统==
				- 所以AM需要对对于设备的访问做封装。
					- 如果不封装，写运行在NEMU上的层序时就需要用访存语句去手动访问，很不方便
				- 因此每一个设备的驱动要做的事就是去访问对应的内存区域， 将值返回或者做一定处理之后返回
		- ## 实现IOE的一般思路：
			- 先看在NEMU中给出的相关设备的行为，它们有多大的内存空间，行位是怎样的，调用该设备之后对应地址里的返回值的意义是什么
			- 然后在平台相关驱动中利用访存语句去与设备沟通
- # 冯诺依曼结构计算机
	- 冯诺依曼结构的计算机由**五部分**构成：
		- 运算器
		- 控制器
		- 存储器
		- 输入设备
		- 输出设备
	- 遵循取指->译码->执行的工作方式
- # 补充
	- [[C内联汇编]]
	- [[库函数stdarg]]
	- ## C在栈上分配的空间
		- 每一次函数调用都会在栈上划分一定的空间
		- 本地变量都是分配在这个栈空间上
		- 因此对于一个本地的数组，有可能每次调用该函数的时候，都位于同一片物理地址。
			- 所以初始化很重要，例如声明一个字符串，使用前建议把首字符设置为``\0``
			-
	- ## C和C++的混编
		- ``extern "C"``，用于让C能够连接C++的函数
			- C++中有函数名重载，因此C++编译器不能将函数名作为唯一的ID进行连接
				- 因此C++编译器会给每一个函数附加诸如参数类型的额外信息
			- 而C不能进行函数名重载，因此没有这方面的考虑
			- 在C++中加上``extern "C"``的关键字之后，C++编译器将不会再给该函数附加额外信息
			- 可以单独使用，也可以作为代码块使用
				- ```
				  extern "C" void foo(int);
				  extern "C"
				  {
				     void g(char);
				     int i;
				  }
				  ```
	- ## 定义是如何从Kconfig最终到c文件中的？
		- Make会调用生成menuconfig的命令
		- 该命令从Kconfig文件生成图形化菜单
		- 在菜单中配置之后，生成.config文件
		- 通过.config文件中的东西生成autoconf.h头文件，所有定义都在其中
			- 应该是在执行mconf或conf是完成的头文件生成
			- 具体生成函数在confdata.c文件中
	- ## ELF文件中的符号表
		- 位于文件的``.symtab``段
	- ## 什么时候getopt-long会返回1？
		- 在指定optstring的时候，如果在开头加一个``-``，则如果处理到一个不匹配的字符串，则返回值则会是1
		- 似乎只会对遇到的第一个不匹配参数有用
- # 部分问题回答
	- ## 错误码为什么是1？make程序如何得到这个错误码
		- 测试用例调用的check函数在测试不通过时会调用``halt(1)``
		- 该函数的具体实现为调用相关平台的``nemu_trap(code)``宏，且调用时会把1作为参数传入
		- ``nemu_trap(code)``在riscv平台下的具体定义为：
			- ``asm volatile("mv a0, %0; ebreak" : :"r"(code)``
			- 为内联汇编代码
		- nemu在执行ret语句时会调用宏``NEMUTRAP(s->pc,R(10))``
			- R(10)为读取寄存器a0的值
			- 该宏的详细定义为``#define NEMUTRAP(thispc, code) set_nemu_state(NEMU_END,thispc,code)``
		- ``set_nemu_state(int state, vaddr_t pc, int halt_ret)``函数会设置各种nemu_state结构体中的各种属性，具体的：
			- ```
			  nemu_state.state = state
			  nemu_state.halt_pc = pc;
			  nemu_state.halt_ret=halt_ret
			  ```
		- 而在nemu对于每一条指令的执行过程中，如果nemu_state的状态变味了END，nemu将会停止执行，并且在nemu-main.c的main函数中，返回值时会判断nemu_state中的halt_ret，如果不为0，则会返回1
	- ## 理解volatile关键字
		- volatile关键字主要是告诉编译器不要乱动(优化)代码，用volatile修饰的变量，每次被引用都会去内存中读取最新值，多次连续的赋值语句也不会直接只赋最后一个值
		- ### 如果代码中`p`指向的地址最终被映射到一个设备寄存器, 去掉`volatile`可能会带来什么问题?
			- 如果这是一个对于设备的****控制代码，不加volatile的情况下，除了最后一次赋值之外的所有语句，包括循环都会被优化掉，这显然是部队的
			- 每一次赋值都有可能是在和设备通信，第一次赋值0可能是在向设备发送控制信号，然后使用一个循环监听设备的回应，若被优化掉，则整个设备控制逻辑就全乱了
	- ## 在kernels/hello下执行make语句之后，如何组织文件编译生成可执行文件
		- hello目录下有一个Makefile，在该目录执行make命令会首先执行该文件
			- 该文件只定义了NAME变量和SRCS变量
				- SRCS变量就是所有代码源文件的集合
				- 这次定义，把自己(hello.c)加了进去
			- 然后include了$(AM_HOME)下的Makefile中的规则，所以接下来会按照该目录下的Makefile进行进一步处理
		- 在$(AM_HOME)下，
			- 首先会进行一系列的检查，包括给出的架构参数是否有效等
			- 然后会对building的一些参数进行赋值，例如输出的路径等
			- 然后引入\$(AM_HOME)/scripts/$(ARCH).mk文件
				- 该文件又会引入额外两个.mk文件，该文件定义了最终的目标，即image，而image目标又是依赖于一个.elf文件的，所以会开始递归构建该elf文件
					- 该elf文件依赖于\$(OBJS), am和$(LIBS)，即目标文件，am文件夹(?)和所有的库文件
					- 库文件包括由am编译出的库文件和由klib编译出的库文件
					- 而$(AM_HOME)下的Makefile又会在执行实际目标的构建之前递归调用每一个库文件所在目录下的Makefile中的规则
						- 此调用是通过$(MAKE) -C调用的，个人理解相当于另开一个进程来执行，所有的变量都会被重新定义
						- 每个库文件目录下的规则很简单，定义NAME和SRCS(该SRCS包含了库下所有的c文件)，然后又一次引入$(AM_HOME)下的Makefile，开始构建库
						- 构建库时会对每一个.c源文件都编译一个位于目标目录下的.o文件
						- 然后使用编译出的目标文件打包为一个.a库文件
					- 而目标文件由最开始的SRCS编译的.o目标文件，在目前的情形下就是hello.c
		- 所以最终是把hello.o文件和am编译而来的库文件，klib编译而来的库文件连接起来形成了最终的elf可执行文件，并且会执行一次反编译获得可读的汇编文件和一次objcpy获得可用于加载到nemu中执行的.bin镜像文件