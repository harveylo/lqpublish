- [深入理解ELF文件](https://blog.51cto.com/u_12444109/3026869)
- **Executable and Linkable Format**
- UNIX系统实验室（USL）开发和发布的，作为应用程序二进制接口（Application Binary Interface，ABI）的文件格式
- 分为**三种类型**（也是***目标文件***的三种类型）
	- [[$blue]]==可重定位（Relocatable）文件==：保存着代码和适当的数据，用来和其他Object文件一起创建一个可执行文件或共享文件。
	- [[$blue]]==可执行（Executable）文件：==保存着一个用来执行的程序，该文件指出了如何来创建程序进程映象。
	- [[$blue]]==共享目标文件：==包含了在两种使用环境中链接的代码和数据。首先链接器（ld）可以将它和其余可重定位文件和共享目标文件一起处理，生成另外一个目标文件
		- 比如：编译器和链接器把*.o和*.so一起装配成一个*.exe文件。
		- 动态链接器（Dynamic Linker）可将它与某个可执行文件以及其他共享目标文件组合在一起创建进程映像（比如：动态加载器把*.exe程序和*.so加载进内存执行）。
	- **编译器**和**汇编器**生成可重定位文件和共享目标文件，**链接器**生成可执行目标文件
	- 从技术上来讲：**目标模块(object module)**是一个字节序列，而一个**目标文件(object file)**就是以文件形式存放在磁盘中的目标模块。大多数情况下，这两个概念可以互相替换
- 实际上目标文件有**多种格式**，并不都是**ELF格式的**
	- Windows使用**PE(Portable Executable, PE)**格式
	- MacOS使用**Mach-O**格式
	- 现代x86-64 Linux和Unix系统使用**ELF**格式
	- 各种格式的**基本理念**是相似的
- # 组成
	- 不同类型的目标文件**有不同的组成格式**
	- 具体的组成可以直接man 5 elf查看
	- ## [[$red]]==节和段的关系==
		- **节(section)**和**段(segment)**可以看作组织可执行文件的两种不同视角
		- 节的视角面向**链接过程**，提供了用于连接与重定位的信息(例如符号表)
		- 段的视角面向**执行**，提供了用于加载可执行文件的信息
		- 使用``readelf``命令可以看到section和segment之间的**映射关系**
			- 使用``-l, --program-headers, --segments``均可查看
			- 一个segment可能由0个或多个section组成，但一个section可能包含于任何segment中
		- ELF文件用**program header table**来管理segment
			- 其一个entry描述了一个segment的所有属性，包括
				- 类型
				- 虚拟地址
				- 标志
				- 对齐方式
				- 文件内偏移量
				- segment大小
			-
	- ## 可重定位目标文件
		- ![](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8p7rbEV-s_nV5Ru6X%2F-MI8pJh5IxzFL80HMTY3%2F07-03%20%E5%85%B8%E5%9E%8B%E7%9A%84ELF%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png?alt=media&token=d9d57c1c-24ef-401a-bf91-04bdf60fad68)
		- ### ELF header
			- 以一个魔数开头(四个字节)：``0x7f 0x45 0x4c 0x46``，后三个字节对应ASCII码表中的ELF
			- 还有一些额外的信息，描述了生成该文件的系统的字大小(word size)和自己顺序(大端和小端）等信息
		- ### Sections
			- #### .text：代码段
				- 已编译程序的机器码
			- #### .rodata：只读数据段
				- 比如printf语句中的格式串和switch语句的跳转表
			- #### .data：数据段
				- 一初始化的全局和静态C变量
			- #### .bss(block starting symbol)：未初始化数据段
				- 未初始化的全局和静态C变量和所有被初始化为0的全局或静态变量
				- 在目标文件中，这个节不占据实际空间，仅仅作为占位符
				- 区分未初始化和已初始化变量是为了节省空间
				- 运行时在内存中分配空间，初始值为0
				- **注：**为什么未初始化数据段叫做.bss？
					- 说白了还是一脉相承的**传统**
					- 起始于IBM704汇编语言
					- 可以把bss记为(Better Save Space)的缩写，方便理解
			- #### .symtab：符号表
				- 存放程序中定义和引用的**全局**变量的信息
				- [[$red]]==**并不是只有在gcc编译时加上-g选项才会生成符号表！**==
				- 每一个可重定位目标文件都会有符号表，除非使用``strip``指令去掉符号表
			- #### .rel.txt：.text节重定位列表
				- 记录了一系列text节中的位置
				- 当连接器将此文件和其他文件组合时，需要修改这些位置
				- 一般来说，任何调用玩不函数或者引用全局变量的指令都需要修改
				- **可执行目标文件**一般不再需要重定位信息，通常省略此节，除非显式地要求包含这些信息
			- #### .rel.data：.data节重定位列表
				- 记录了data节中的一系列位置
				- 这些位置在链接时也需要被重定向，一般包含了所有已初始化且初始值为一个全局变量地址或外部定义的函数地址
			- #### .debug：调试符号表
				- 包含程序中定义的局部变量和类型的定义，程序中定义和引用的全局变量和原始的C源文件代码
				- 在使用gcc编译时，使用``-g``指令才会在编译完成的目标文件中包含这张表
			- #### .line：源代码映射表
				- 原始C程序源代码和.txt节中机器指令之间的映射，包含方式同上
			- #### .strtab：字符串表
				- 包含了symtab和debug节中，以及节头部需要用到的字符串
		- ### 节头部表
	- ## 可执行文件
		- 能够直接被加载进内存并运行的文件
		- 相较于可重定位文件，多了一个段头表
		-
- # 符号和符号表
	- 每个可重定位模块m都有一个符号表，包含m定义和引用的符号信息
	- ## 符号
		- 在连接器的上下文中有三种不同的符号
			- **全局符号**：由模块m定义且能够被其他模块引用的非静态C函数和全局变量
			- **外部符号**：由其他模块定义并被模块m引用的非静态C函数和全局变量
			- **局部符号**：制备模块m定义和引用的静态C函数和全局变量或者函数中定义的静态变量，这些符号在模块m中任何位置都可见，但是不能被其他模块引用
				- **[[$red]]==注意==**，局部符号的**“局部”**概念和C程序编写时的**“局部”**概念并不相同，局部符号往往是全局变量，而真正的C程序局部变量在栈上管理
	- ## 符号表
		- 符号表由汇编器构造
		- 本质是一个符号表项数组
		- 每一个符号表项本质上是一个Elf64_Symbol结构体
		- ```
		  typedef struct { 
		      int   name;      /* String table offset */ 
		      char  type:4,    /* Function or data (4 bits) */ 
		      binding:4;       /* Local or global (4 bits) */ 
		      char  reserved;  /* Unused */  
		      short section;   /* Section header index */
		      long  value;     /* Section offset or absolute address */ 
		      long  size;      /* Object size in bytes */ 
		  } Elf64_Symbol;
		  ```
			- 该结构体定义在系统头文件``elf.h``中
		- 符号表中**value**，对于可重定位模块来说，是在对应节中的偏移量，对于可执行文件来说是绝对地址
		- 有三类**伪节(pseudosection)**是没有节头表条目的
			- **ABS**
				- 不需要重定位符号，比如源代码的路径名
			- **COMMON**
				- 未初始化全局变量
				- .bss保存的是未初始化的静态变量，初始化为0的全局变量和静态变量
				- value字段给出对齐要求
				- size给出最小大小
			- **UND**
				- 在目标文件中引用，但定义在别的文件中的符号
			- 只有可充定位目标文件才有存在伪节，可执行目标文件中是没有的
		- 注意：name成员并不是一个字符串，而是在strtab中的偏移量
- # 符号解析
	- 符号解析是**链接**的一个阶段性过程
	- 对于本地的符号解析，连接器可以很简单地办到
	- 但对于全局外部符号的解析，将较为复杂
	- 在C中，只允许全局唯一的函数名，不允许函数名重载
	- ## C++和Java如何完成函数名重载
		- C++和Java通过符号**重整(mangling)**的方式完成函数名重载
		- 相反的过程叫做**恢复(demanging)**
		- 通过重整，可以生成**对连接器来说**全局唯一的函数名
		- 被重整的类的名字为名字中的字符的数量跟上原始名字
			- 如，``Foo``将被重整为``3Foo``
		- 被重整的函数名为函数名加上下划线，后接重整后的类名和参数类型的首字母编码
			- 如，``Foo::bar(int,long)``被重整为``bar_3Fooil``
	- ## 连接器如何解析多重定义的全局符号
		- 连接器的输入是一组可重定位目标模块，而每个模块都带有若干符号
		- 当多个模块定义同名的全局符号时，**Linux**编译系统采用如下方式：
			- 编译器向汇编器输出每个全局符号的强弱(strong, weak)程度
				- 函数和已初始化的全局变量是**强符号**
				- 未初始化的全局变量是**弱符号**
			- 汇编器将强弱信息隐含地编码在可重定位目标文件地符号表里
		- 根据符号的强弱，Linux连接器按如下规则处理多重定义地符号名
			- **不允许**有多个同名的强符号
			- 如果一个强符号和多个弱符号同名，**选择强符号**
			- 如果有多个弱符号同名，从弱符号中**任选一个**
	- ## 静态库引用解析
		- 连接器按从左到右的顺序扫描在命令行参数中给出的目标文件和库文件
		- 扫描过程中维护三个集合
			- 可重定位目标文件的集合**E**(该集合会被最终用于生成可执行文件)
			- 未解析符号集合(被引用但尚未找到定义的符号)**U**
			- 已定义符号集(已经在之前被扫描文件中找到定义的符号)**D**
			- 初始时，三个集合均初始化为空
		- 对于命令行中给出的每一个输入文件f，连接器首先判断f是一个目标文件还是库文件。
			- 如果是目标文件，将f添加到E中，修改U和D来反映f中的符号定义和引用
			- 如果是一个库文件，则尝试将U中的未定义符号和库中成员文件的定义符号比较
				- 如果库中某个成员文件m定义的符号存在于U中，则将m添加到E中，并且修改U和D来反映m中对符号的定义和引用
				- 如果m定义的符号都不在U中，则忽略该文件
				- 重复以上判断和处理，直到U和D不再发生变化，则表示对于该库文件的处理完成，继续对下一个来自命令行参数的文件进行处理
		- 完成了对于所有命令行中给出文件的处理之后，如果U仍是非空的，则连接器输出错误信息且终止
		- 反之，合并并重定位E中的目标文件，构建可执行文件
		- 如此的处理方式使得在命令行中给出的[[$red]]==**文件顺序**==变得十分重要
			- 如果一个引用某个符号的文件出现在定义该符号的文件或库之后，则解析将会失败
			- 一般的准则是，将库文件放在最后，且库函数之间也要保证引用要在定义之前
			- 为了保险起见可以重复给出库文件，或者把存在依赖关系的两个库合并
		-
			-
			-
- # mips-sde相关工具使用
	- [[$blue]]==编译==
		- ``mips-linux-gnu-as –mips32 [源文件路径] -o [目标文件路径]``
	- [[$blue]]==链接==
		- ``mips-linux-gnu-ld -T [脚本名] [源文件路径] -o [目标文件路径]``
	- [[$blue]]==阅读ELF文件==
		- ``mips-linux-gnu-readelf``
		- ``-h``，阅读文件头
		- ``-l``，阅读program header
		- ``-S`` 阅读分段信息