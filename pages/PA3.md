- # 个人思考
	- ## 对于AM(abstract-machine)的理解
		- 一开始我认为AM就是一个操作系统，加载程序到nemu的内存指定位置，然后执行
		- 然而实际上AM应该是一个特殊的抽象层，正如其名字**abstract machine**一样是一台省去了物理实现的抽象计算机
		- AM实际做的事是在物理计算机(NEMU)的基础上增添了一层新的抽象层，将NEMU的实现细节(指令集等)全部略去，使得后续的实验可以很方便地展开
		- 不过AM也做了一部分操作系统会做的事，例如库函数地实现等
- # 操作系统对硬件的需求
	- 一个最基础的操作系统需要**做两件事**
		- 用户程序结束之后，跳转到操作系统的代码继续执行
		- 可以加载一个新的用户程序来执行
	- 以上两点要求程序之间的执行流切换
		- 单个程序内部的执行流切换很常见，函数调用就是
		- 执行流切换的本质还是改变PC值
	- 最初的操作系统就是一些库函数的集合，使用``call``，``jal``等指令完成执行流切换
		- 用户程序退出时，调用库函数中的特殊函数将执行流返还给操作系统
		- 缺点在于，如果用户程序崩溃了，则将导致操作系统的崩溃
		- 而且让用户随意进行任意的PC切换，很有可能会导致若干安全问题
	- 所以操作系统需要的是**[[$red]]==限制入口==的执行流切换**
		- 而实现这一点需要硬件支持
	- ## 硬件支持：执行模式分级
		- 硬件引入若干手段将当前执行程序的等级区分开、
		- 只有高特权级的程序才能执行一些系统级别的操作
		- 低特权程序尝试执行高特权操作时，CPU会抛出异常信号
		- 在硬件视角下，CPU实际并无法区分自己正在执行哪一个程序
			- 因此一般提供一个特权寄存器保存当前处理器所处的特权层级
			- 一些指令可以用于检查当前特权等级
		- 在RISCV下，存在M，S，U三个特权模式，分别代表机器模式，监管者模式和用户模式
			- 通常来说，操作系统运行在S模式
- # 自陷指令
	- 特权分级实际上是使得用户程序不再能随意进行执行流切换，使限制入口执行流切换具有了意义
	- 实际实现限制入口执行流切换的是自陷指令，也是由硬件提供
	- 程序执行自陷指令之后会跳转到操作系统预先设定好的跳转目标
		- 这个跳转目标也称为**异常入口地址**
	- 这一系列的操作是ISA规范的一部分，称为**中断/异常响应机制**
		- 大多数ISA不区分CPU异常和自陷和硬件中断，而是做统一处理
	- ## RISCV
		- 提供``ecall``指令作为自陷指令
		- 提供mtvec寄存器存放异常入口地址
		- 提供CSR(空置状态寄存器)保存程序当前状态
			- PA中使用三个CSR寄存器
				- **mepc**(Machine Exception PC)：存放触发异常的PC
				- **mstatus**(Machine Status)：存放处理器的状态(全局中断使能(globle interrupt enable)等很多其他信息)，结构如下所示
					- ![image.png](../assets/image_1674546567451_0.png)
				- **mcause**(Machine Exception Cause)：存放触发异常的原因
			- 剩下的CSR寄存器
				- **mtvec**(Machine Trap Vector)：保存发生exception时处理器需要跳转到的地址
				- **mie**(Machine Interrupt Enable)：指出处理器目前能处理和必须忽略的中断
				- **mip**(Machine Interrupt Pending)：列出目前正准备处理的中断
				- **mtval**(Machine Trap Value)：保存trap的附加信息
					- 地址exception中出错的地址
					- 发生非法指令exception的指令本身
					- 对于其他异常，值为0
				- **mscratch**(Machine Scratch)：暂时存放一个字大小的数据
		- ### 触发exception后的响应过程(简化)
			- 将当前PC值保存到mepc寄存器
			- 在mcause寄存器中设置一场号
			- 从mtvec寄存器中读取异常入口值
			- 跳转到异常入口地址
		- 在实际的硬件上，对异常的响应还涉及到特权等级切换等操作
		- ISA手册中会记录处理器对中断号和异常号的分配和相应处理
	- 异常处理完成之后的工作交由操作系统完成，操作系统会视情况决定是否继续执行程序
		- riscv通过``mret``指令从异常处理过程中返回，并根据mepc寄存器恢复pc
	- ## 状态机视角下的异常响应机制
		- 在之前的PA中提到过，程序时一个状态空间为$$S=<R,M>$$的状态机
		- 如果要给这个状态机增添异常响应机制，则首先需要对状态空间进行扩充
		- R需要扩充，使其包含特殊寄存器(系统寄存器System Register)
			- $\mathrm{S=\{GPR,PC,SR\}}$
		- M不需要修改，异常响应机制没有对内存做出改变
		- 对状态转移的扩充需要追加考虑指令执行“失败”时的操作
			- 引入一个虚拟的指令，执行该指令则代表进入了异常处理
- # 将上下文管理抽象为CTE
	-