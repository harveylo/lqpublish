- # 从输入网址到实际展示
	- ## 第一步：浏览器解析URL
		- ![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg){:height 788, :width 622}
		- 若图一的蓝色部分全部省略，则请求的根目录下事先设置的**默认文件**，一般为``/index.html``或``default.html``
		- 浏览器解析URL之后，即能**确定Web服务器和文件名**，然后将生成HTTP请求
	- ## 第二步，获取IP地址(DNS)
		- ### 域名的层级关系
			- 一个完整的域名实际上最后还有一个点，如``www.harvey.com.``
			- 越靠右**层级越高**，如在上面的域名中：
				- ``.``：根DNS服务器
				- ``.com``：顶级域服务器
				- ``harvey.com``权威DNS服务器
				- ![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg){:height 325, :width 470}
			- 根域的服务器信息保存在素有物联网DNS服务器中
			- 每次解析某个域名的IP地址时，首先会检查本地的DNS缓冲，如果找到了对应IP，直接访问，否则向上询问DNS服务器
			- ![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)
	- ## 第三步，将数据递交协议栈
		- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg){:height 488, :width 466}
		- **ICMP在IP之上**，需要依赖IP报文完成工作
		- **ARP在IP之下**，不依赖IP报文，IP协议依赖ARP获取的MAC地址将数据地送给下一层(链路层)
		- **HTTP使用TCP作为其协议栈的第一层**
	- ## 第四步逐层封装
		- HTTP协议的所有数据(包括头部)首先被封装为TCP协议，然后TCP协议的所有数据又被封装到IP报文中
		- IP报文最后又会被加上MAC头部，直接发送给对应的网络设备
		- 每一层之间都需要进行一次**地址的转换**
			- **[[$red]]==从HTTP到TCP：==**
				- 需要知道端口，一般默认的是HTTP:80，HTTPS:443
				- 知晓之后即可封装TCP帧
			- **[[$red]]==从TCP到IP：==**
				- 需要知道IP地址，通过DNS获取
				- 知晓IP地址之后，即可通过路由表知晓须向哪个IP地址转发
			- **[[$red]]==从IP到实际链路层协议：==**
				- 需要知道某个IP地址对应的MAC地址，一般通过ARP协议获取
		- ![MAC 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg){:height 942, :width 485}
	- ## 第五步发送并转发
		- ### 经过交换机
			- **交换机是在一个局域网内负责转发**
			- 一个链路层帧在转发过程中会经过若干**交换机**，交换机工作在链路层，在TCP/IP四层模型中处于最下层，但是在OSI七层模型中位于第二层，因此也叫**二层网络设备**
			- 交换机自身不具有MAC地址，对发送来的所有MAC帧不会进行匹配检测，而是直接根据转发表，将包根据目的MAC地址向对应端口转发
			- 如果一个MAC帧的目的地址和转发表中的所有地址都不匹配，则会向除了源端口以外的所有端口转发
			- 广播地址的MAC帧也会被向所有端口转发
				- MAC的广播地址：``FF:FF:FF:FF:FF:FF``
				- IP的广播地址：``255.255.255.255``
		- ### 经过路由器
			- 路由器比交换机高一层，属于**三层设备**，其转发和寻路**基于IP地址而不是MAC地址**
			- 会查询目标MAC地址是否和自身MAC地址匹配，不匹配则丢弃，反之放入缓冲内
			- 被路由器接收的包会被去掉MAC头
		- 在转发的过程中，**[[$red]]==源IP和目标IP永远不会变==**，但MAC地址会随着转发的进行被改变若干次
	- ## 第六步，到达目的主机并应答
		- 数据到达目的主机之后，目的主机会逐层解包，最终获取应用层数据(HTTP)
		- 目的主机(服务器)在获取应用层数据并做出相应操作之后即可将回应发送给源主机(客户端)
		- 在将回应发送给客户端的构成中又会重复之前的过程
- # Linux如何收发网络包
	- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png){:height 734, :width 383}
	- ## 当linux收到一个网络包时：
		- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png)
		- 网卡通过DMA技术，将网络包写入指定内存地址，网卡向CPU**发起硬件中断**
		- CPU收到**硬件中断**，通过**中断表**调用已注册**中断处理函数**
			- 在处理硬件中断时需要关中断
			- 硬件中断处理完成之后，**发起软中断**
		- -------------------硬件处理完成----------------------
		- 接下来的处理就进入**软件层面**
		- 内核中，``ksoftirqd``线程专门负责软中断处理，通过轮询处理数据
			- 从ring buffer中获取一个数据帧，作为网络包交由协议栈进行逐层处理
	- ## 当liux发送一个数据包
		- linux中对于网络数据帧都是通过``sk_buf``结构体来保存的
			- 为了各层之间传输数据的遍历和通用性，任何层的网络包数据均以此结构体保存
			- 为了做到这一点
				- 在从底层到高层剥离头部的时候，``skb->data``的值会被逐渐增加
				- 在从高层到底层逐步包装的时候，会提前预留足够的内存空间，通过减少``skb->data``即可填充头部
				- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/sk_buff.jpg){:height 303, :width 424}
		- 准备好数据之后通过软中断告知网卡，网卡即可通过DMA访问内存获取数据并发送
	- ## 发送网络数据，设计几次内存拷贝操作？
		- 最多三次，最小两次
		- **第一次**
			- 调用系统调用，内核申请一个内核态``sk_buff``内存空间， 将用户待发送数据拷贝到此``sk_buff``内存空间，加入发送缓冲区
		- **第二次**
			- 从传输层进入网络层时，每个``sk_buff``都会被克隆一个新的副本，副本被送入网络层在发送完成之后被释放，原本的数据会在收到其对应的ACK之后才会被释放
		- **第三次**
			- 当IP层发现``sk_buff``大小大于MTU(Maximum Transmit Unit)时，会申请额外的``sk_buff``，并将原来的``sk_buff``拷贝为多个小的``sk_buff``