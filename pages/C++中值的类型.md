- [[$red]]==**注意**==：官方文档对于左右值得定义**十分模糊**，难以理解，后面的很多内容来自官方文档，因此可以用一种简单得方式区分左右值：
	- 凡是**可以取地址的**，**有名字的**(具名)，**非临时**的值就是左值
		- 在内存中有存放地址
	- 干事**不可取地址的**，**没名字的**(匿名)，**临时的**值就是右值
		- 在地址中没有地址，可能整合在指令中，也有可能在寄存器中
- 一个**表达式**(Expression)由两部分定义，**类型**(type)和**值类型**(value category)
- 每一个表达式都有某种**非引用(non-reference)**的类型，并且每一个表达式都拥有**三种值类型之一**：
	- **prvalue**
	- **xvalue**
	- **lvalue**
- ![C++ | Value Categories](http://i.stack.imgur.com/C09fH.png)
- # 主类型(Primary Categories)
	- ## lvalue
		- **左值**，可以出现在表达式的左侧，这个名字属于历史遗留，实际可定义为**不是xvalue的glvalue**
		- **举例：**
			- 函数名和变量名（实际上是函数指针和具名变量，具名变量如std::cin、std::endl等）
			- 返回左值引用的函数调用
			- 前置自增/自减运算符连接的表达式(++i, --i)
			- 由赋值运算符或符合赋值运算符来连接的表达式(a=b, a+=b)
				- 作左值时表示连续赋值
				- ``a=12;b=12;(a=b+1)+=23;  // a== 36``
			- 解引用表达式(*p)
			- 字符串字面值("abc")
				- [[$red]]==为什么字符串字面值是左值？==
					- 字符串常量不同于一边的字面量，其必须储存在内存中，不可能直接在指令或寄存器中存储
					- 既然在内存中，那么自然能够取到地址，所以被看作左值合理
			- 带下标的数组名
		- 简单地说：**具名的**，可以**取地址**
	- ## prvalue
		- **纯右值**(pure value)，包含：
			- 纯粹的**字面值**(如``3``, ``false``等，不具有结果对象)
			- 求职结果相当于字面值，或者是一个**不具名的临时对象**
			- 初始化一个对象(这样的纯右值具有**结果对象**)
				- 一个结果对象可能是一个变量，一个new出来的对象等
		- 在某些情况下，纯右值会被转化为一个将亡值，这一过程叫做**Temporary Materialization**
		- **举例**：
			- 除字符串字面值以外的字面值
			- 返回非引用类型的函数调用
			- 后置自增/自减运算符连接的表达式(i++/i--)
			- 算术表达式（a+b、a&b、a<<b）
			- 逻辑表达式（a&&b、a||b、~a）
			- 比较表达式（a==b、a>=b、a<b）
			- 取地址表达式（&a）
	- ## xvalue
		- **将亡值**(expiring value)，指明一个资源可以被重用的对象
		- 在C++之前，右值和纯右值是**等价的**，随着C++11引入右值引用产生此概念
		- 将亡值与**右值引用息息相关**，包含：
			- **返回右值引用**的函数表达式
			- 转换为右值引用的转换函数的表达式
		- 简单来说就是其自身的生命周期即将结束，但是他的资源可能被移动到一个新的别名继续使用
		- 其存在的意义就是作为一个临时的符号传递值
- # 复合类型
	- ## glvalue
		- **泛左值**(generalized lvalue)，其值指明一个对象或函数的身份
		- 可以被取内存地址
	- ## rvalue
		- **右值**，可以出现在表达式右侧的值，是将亡值或纯右值
		- 一般以一下的**右值引用**，就是指的对于rvalue的引用，即包含xvalue和prvalue
		- 右值都可以直接被移交所有权