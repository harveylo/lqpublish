- # const 与 define
	- ``#define``宏只是简单地做替换，不具有类型
	- ``const``可以同时做到防篡改和类型安全
	- 除非一些特定用法，一般推荐用`const`, `inline`, `enum`等替换宏
- # const修饰
	- ## 修饰一般变量
		- 必须进行初始化
		- 常量一般存放在`.rodata`段
			- 若[[$red]]==**时间统计优化(?)**==等级开得高，且不存在取地址，则可能优化成立即数放置在``.txt``段中
	- ## 修饰类
		- ### 修饰成员变量
			- 则该成员变量必须在初始化列表中进行初始化，不能进行复制
		- ### 修饰类静态成员变量
			- 和普通静态成员变量类似，推荐放到类外.cpp文件中初始化
		- ### 修饰类对象
			- const得类对象只能调用const函数
			- 若类中某些变量对于const对象来说也是可以修改的，则可以用``mutable``关键字修饰此变量
				- 此方法并不常用，此情况也并不常见
		- ### 修饰成员函数
			- 标识这个函数可以被const对象调用
				- 也可以被普通对象调用
			- const成员函数不会(也不能)改变对象的成员
			- const成员函数内部也不能调用非const成员函数
	- ## 修饰指针
		- ### 地址可变，指向内容不可变
			- ``const char * p``
			- ``char const * p``
			- 只要const 出现在``*``之前就表示是指向的内容不可变
		- ### 地址不可变，内容可变
			- ``char * const p``
			- const 出现在``*``之后，在变量名之前，则表示指针的地址不能变(指针本身的值不可变)，但指向得内容可变
		- ### 地址和内容均不可变
			- ``const char* const p``
			- 将上述两种方式结合起来，则指向内容和指针本身的值都不可变
	- ## 修饰引用
		- 和修饰对象类似，表示内容不可更改
		- 作为函数参数传参则不存在copy开销(引用性质决定，和const修饰与否无关)
		- 被``const``修饰的引用可以直接使用一个常量进行初始化
			- 相当于将一个常量固化了下来
			- ``const int& a = 10;``
		- `` const int& a = 10; const int& b = a*2;``
			- 使用这种进行初始化时，实际上编译器会创建一个临时变量来处理转换结果，实际上还是对一个临时变量进行了引用
- # constexpr
	- 在**C++ 11**中引入
	- 说明此表达式是一个常量表达式，在编译时就可以确认其值
	- 常用于模板中进行**递归求值**
	- ```
	  template <int N>
	  struct binary {
	    static constexpr int value = binary<N / 10>::value << 1 | N % 10;
	  };
	  
	  template <>
	  struct binary<0> {
	    static constexpr int value = 0;
	  };
	  ```
	- 例如上述程序可以递归求一个用int表示的二进制形数的值