- # 基于TCP的半关闭
	- TCP的**断开连接比建立连接过程更重要**，因为断开过程更容易产生变数
	- Linux的close函数和closesocket函数意味着完全断开连接，**既不能传输也不能接收**
		- 因此调用这两个函数显得不太优雅
	- **半关闭**即指的是**只关闭传输或接收流**，而不是双向通道同时关闭
	- ## 针对优雅断开的shutdown函数
		- ``shutdown``
			- **头文件**：``<sys/socket.h>``
			- **参数**：``int sock, int howto``
				- howto标识断开的方式，有如下三种取值
					- ``SHUT_RD``：断开输入流，输入缓冲中受到的数据会被抹去
					- ``SHUT_WR``：断开输出流，会将输出缓冲中的残留数据 地送到目标主机
					- ``SHUT_RDWR``：同时断开输入输出流
			- **返回值**：成功返回0，失败-1
	- ## 为什么需要半关闭
		- ![image.png](../assets/image_1682688394574_0.png){:height 323, :width 305}
		- 考虑以上场景，最后客户端在受到文件之后需要再向服务器端发送消息，此处是一个多余的thank you
		- 如果仅使用close，虽然能送出EOF，但是也无法再接收客户端发来的消息
		- 因此可以使用shutdown，先关闭输出流，再使用read接收客户端消息
	- **[[$red]]==注意：==**shutdown函数仅用于关闭输入输出流，关闭socket本身并释放socket资源还是需要最终调用close
-