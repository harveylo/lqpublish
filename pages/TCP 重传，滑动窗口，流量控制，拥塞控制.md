# 重传机制
	- TCP确保可靠传输的一大关键机制就是重传机制，在丢包和传输数据出现错误的情况下，接收方通过重传机制要求对方重新传输数据。
	- TCP中有**四大重传机制**
	- ## 超时重传
		- 每一个TCP帧发送之后都会设置一个定时器，若超过定时器设置时间还没有收到对方的ACK确认应答报文，就会向对方重发这一帧
		- **[[$red]]==数据包丢失==**和**[[$red]]==确认帧丢失==**都会触发超时重传
		- ![image.png](../assets/image_1694767773037_0.png){:height 437, :width 590}
		- ### 超时间隔的设置
			- **超时重传间隔(Retransmission Timeout, RTO)**的选择往往和**RTT(Round Trip Time)**有关
			  collapsed:: true
				- RTT即从发送信息到收到对方确认信息的时间
				- ![image.png](../assets/image_1694768365881_0.png)
			- 如果RTO过大会导致重传效率低下，丢的包需要等很久才会重传
			- 如果RTO过小(小于RTT)会导致重发过多过快，导致网络拥塞
			- RTO的选择应该略大于RTT，但是**RTT是会[[$red]]==动态变化==的**，需要有专门的算法来计算RTO
			- **linux中的RTO计算算法**
				- 通过两个采样估计RTO：
					- 采样RTT值，计算加权平均的平滑RTT值，随网络情况动态变化
					- 采样RTT波动范围，避免RTT大波动导致预测失效
				- 采用了**RFC2988**标准用于计算RTO
				  collapsed:: true
					- ![image.png](../assets/image_1694771085754_0.png)
					- Linux中，$\alpha=0.125,\beta = 0.25,\mu=1,\partial=4$，这些系数的选择是通过大量实验获得的
				- **每遇到一次超时重传，[[$red]]==下一次超时间隔将翻倍==**
				- 若连续遇到两次超时，则说明网络环境差，不宜频繁反复发送
	- ## 快速重传
		- **Fast Retransmit**
		- ![image.png](../assets/image_1694772203891_0.png)
		- 即**若收到[[$red]]==连续三份相同的ACK帧==**，则会在某一数据帧超市之前直接重传
		- 快速重传的一个问题是发送发不知道对方到底有多少数据没收到，例如在上图中，发送方并不知道接收方是只有2没收到，还是2以后的所有包(2,3,4,5)都没收到
			- 如果只重传2，那么如果后续的包实际上都丢了，那么重传效率十分低下
			- 如果2之后的全部重传，那么占用了额外的网络资源，可能导致网络拥塞
	- ## SACK
		- **选择性确认(Selective Acknowledgement)**
		- 用于解决快速重传中无法确认重传数据范围的问题
		- 启用此特性会在TCP头部的**选项字段**中添加一个**SACK**域，此域的信息用于告知发送方有哪些数据已经收到。
		- 当连续三个相同ACK序列号的确认帧发送到发送方，发送方即可通过SACK的信息判断出需重传哪些数据
		- ![image.png](../assets/image_1694772702228_0.png)
		- 需要通信的两台电脑都支持sack才可启用此功能，linux中可以修改`/etc/sysctl.conf`中的`net.ipv4.tcp_sack`字段来开启此功能(**linux 2.4之后默认开启**)
	- ## D-SACK