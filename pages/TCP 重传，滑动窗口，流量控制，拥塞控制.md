# 重传机制
	- TCP确保可靠传输的一大关键机制就是重传机制，在丢包和传输数据出现错误的情况下，接收方通过重传机制要求对方重新传输数据。
	- TCP中有**四大重传机制**
	- ## 超时重传
		- 每一个TCP帧发送之后都会设置一个定时器，若超过定时器设置时间还没有收到对方的ACK确认应答报文，就会向对方重发这一帧
		- **[[$red]]==数据包丢失==**和**[[$red]]==确认帧丢失==**都会触发超时重传
		- ![image.png](../assets/image_1694767773037_0.png){:height 437, :width 590}
		- ### 超时间隔的设置
			- **超时重传间隔(Retransmission Timeout, RTO)**的选择往往和**RTT(Round Trip Time)**有关
			  collapsed:: true
				- RTT即从发送信息到收到对方确认信息的时间
				- ![image.png](../assets/image_1694768365881_0.png)
			- 如果RTO过大会导致重传效率低下，丢的包需要等很久才会重传
			- 如果RTO过小(小于RTT)会导致重发过多过快，导致网络拥塞
			- RTO的选择应该略大于RTT，但是**RTT是会[[$red]]==动态变化==的**，需要有专门的算法来计算RTO
			- **linux中的RTO计算算法**
				- 通过两个采样估计RTO：
					- 采样RTT值，计算加权平均的平滑RTT值，随网络情况动态变化
					- 采样RTT波动范围，避免RTT大波动导致预测失效
				- 采用了**RFC2988**标准用于计算RTO
				  collapsed:: true
					- ![image.png](../assets/image_1694771085754_0.png)
					- Linux中，$\alpha=0.125,\beta = 0.25,\mu=1,\partial=4$，这些系数的选择是通过大量实验获得的
				- **每遇到一次超时重传，[[$red]]==下一次超时间隔将翻倍==**
				- 若连续遇到两次超时，则说明网络环境差，不宜频繁反复发送
	- ## 快速重传
		- **Fast Retransmit**
		- ![image.png](../assets/image_1694772203891_0.png)
		- 即**若收到[[$red]]==连续三份相同的ACK帧==**，则会在某一数据帧超市之前直接重传
		- 快速重传的一个问题是发送发不知道对方到底有多少数据没收到，例如在上图中，发送方并不知道接收方是只有2没收到，还是2以后的所有包(2,3,4,5)都没收到
			- 如果只重传2，那么如果后续的包实际上都丢了，那么重传效率十分低下
			- 如果2之后的全部重传，那么占用了额外的网络资源，可能导致网络拥塞
	- ## SACK
		- **选择性确认(Selective Acknowledgement)**
		- 用于解决快速重传中无法确认重传数据范围的问题
		- 启用此特性会在TCP头部的**选项字段**中添加一个**SACK**域，此域的信息用于告知发送方有哪些数据已经收到。
		- 当连续三个相同ACK序列号的确认帧发送到发送方，发送方即可通过SACK的信息判断出需重传哪些数据
		- ![image.png](../assets/image_1694772702228_0.png)
		- 需要通信的两台电脑都支持sack才可启用此功能，linux中可以修改`/etc/sysctl.conf`中的`net.ipv4.tcp_sack`字段来开启此功能(**linux 2.4之后默认开启**)
	- ## D-SACK
		- **Duplicate SACK**，使用SACK来**告知发送方有哪些数据被重复接收**
		- ![image.png](../assets/image_1694846306245_0.png)
		- 以此让发送方知道，之前发送的数据并没有丢失，而是接收方的确认帧丢失了
		- Linux下通过``sysctl``指令修改``net.ipv4.tcp_dsack``即可开启或关闭此功能(2.4之后默认开启)
- # 滑动窗口
	- 窗口就是**[[$red]]==在没有收到确认应答前能够发送数据量的最大值==(单位：字节)**
	- 操作系统会为每一个tcp链接建立一个缓存空间，发送方主机在缓冲区中保留**已发送但未收到确认帧**的数据。被确认的数据会从缓冲区中清除
	- ACK的序列号表示在此序列号之前的所有数据都已经被收到，这杯乘坐**累计确认**或**累计应答**
	- 每一个TCP帧都会有一个窗口大小域，实时告诉对方自己当前可接受的窗口大小
	- ## 发送方的滑动窗口
		- 数据流被滑动窗口**划分为四部分**
			- ![image.png](../assets/image_1694945309601_0.png)
		- 在实现上，使用两个指针(序列号)和一个窗口大小变量来区分这四部分
			- ![image.png](../assets/image_1694945952243_0.png)
			- ``SND.UNA``，**Send Unacknowledged**，指向已发送但尚未接受的字节流的第一个字节
			- ``SND.NXT``，指向尚未发送但处于发送方接受能力范围内的字节流的第一个字节
			- ``SND.WND``，标识当前接收方的窗口大小，``SND.UNA``+ `SND.WND`即指向第四部分的第一个字节
			- 可用窗口大小为：``SND.WND``- (`SND.NXT` - `SND.UNA`)
	- ## 接收方的滑动窗口
		- 相较于发送方，接收方的滑动窗口要相对简单一些
			- ![image.png](../assets/image_1694947095930_0.png)
		- 使用一个窗口大小变量和一个指针进行划分进行划分
			- ``RCV.WND``，表示接收窗口的大小，这个值会通过tcp帧告知对方
			- `RCV.NXT`，指向期望从发送方接收到的下一个字节(序列号)
			- `RCV.NXT`+`RCV.WND`即可指向第四部分
- ## 流量控制
	- 滑动窗口的引入就是为了处理流量控制问题
	- 核心是**[[$red]]==双方实时沟通对方的接受能力，对发送数据量做出动态调整==**
	-