- 包括如何启动，等待线程，传递参数，已交线程所有权等
- # 线程基本操作
	- 每个程序至少有一个主线程用于执行main函数
	- 创建的线程和主线程一起执行
	- ## 启动线程
		- 简单来说，C++线程库启动线程就是构造``std::thread``对象
		- 构造thread对象一般需要传入一个执行**函数**，也可以传入一个实现了**函数操作符**的**class**
		- ```
		  class background_task {
		  public:
		  	void operator()() const {
		  		do_something(); 
		          do_something_else();
		  	} 
		  };
		  background_task f; 
		  std::thread my_thread(f);
		  ```
		- 提供的函数对象会被复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行
		- 若传入临时变量会导致编译器误以为你要声明一个返回对象为thread的函数，可以采取以下两种方式来避免
			- ```
			  std::thread my_thread((background_task())); // 1 
			  std::thread my_thread{background_task()}; // 2
			  ```
		- 也可以使用lambda表达式定义一个函数对象
		- 线程启动之后必须要在**等待其结束**或**让其自主运行**之间**做出决定**
			- 如果在thread对象被销毁之前还没有做出决定，程序会终止(thread的析构函数会调用`std::terminate()`)
			- 即便是存在异常，也要确保线程在``join``和``detach``两个操作之间二选一
		- ### 确保线程生命周期内访问数据的有效性
			- ```
			  struct func {
			  	int& i; 
			  	func(int& i_) : i(i_) {} 
			  	void operator() () {
			  		for (unsigned j=0 ; j<1000000 ; ++j) {
			  			do_something(i); 
			          } 
			      } 
			  };
			  void oops() {
			  	int some_local_state=0; 
			  	func my_func(some_local_state); 
			  	std::thread my_thread(my_func); 
			  	my_thread.detach();// 1 潜在访问隐患：空引用 // 2 不等待线程结束 
			  } // 3 新线程可能还在运行
			  ```
			- 上述例子在运行过程中很有可能出现问题，因为若oops函数已经返回，则新线程就会访问无效的地址
			- **避免用引用了局部变量的函数去创建线程**
			- 也可以通过join函数确保线程在oops函数返回之前结束