- l1缓存一般分为**指令缓存**和**数据缓存**
- **提升指令缓存命中率**
	- 其实就是提升分支预测命中率，而提升分支预测率的方式就是维持有规律的分支语句
		- 比如对数组进行排序之后，循环中的分支语句将有迹可循
		- 也可以使用``likely``和``unlikely``宏显式告诉编译器分支条件可能的结果
- **提升多核CPU系统的缓存命中率**
	- 考虑把线程绑定到某一个CPU的核心
	- ``linux``提供了``sched_setaffinity``方法，在头文件`<sched.h>`中，用于完成类似功能
		- ``int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t* mask)``
- **伪共享和避免方式**
	- 一个cache line往往包含一块数据，如果两个CPU核心需要处理同一块cache line中的不同数据而导致频繁的缓存失效，这种情况就叫做**伪共享(False sharing)**
	- **解决方法**：对于**多个线程共享的热点数据**，避免这些数据全部处在同一个cache line中
	- 说白了也就是：[[$red]]==**多线程数据cache line对齐**==
		- ```
		  struct test{
		  	int a;
		      int b;
		  }
		  ```
		- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%BC%AA%E5%85%B1%E4%BA%AB/struct_ab.png)
		- 上述a，b在同一个cache line中，如果通过填充将其按cache line的大小对齐，就能避免不同的核心同时处理a和b时产生的false sharing
	- Linux下有宏可以用于直接填充，即``__cacheline_aligned_in_smp``
		- 此宏似乎只能在编写内核模块时使用，不能再用户空间程序中使用
		- ```
		  struct test{
		  	int a;
		      int b __cacheline_aligned_in_smp
		  }
		  ```
		- ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%BC%AA%E5%85%B1%E4%BA%AB/struct_ab1.png)
		- 如此一来，a和b就不在同一个cache line中了
- **CPU如何选择线程？**
	- Linux内核中，线程和进程都用``task_struct``结构体来表示和管理
		- linux中可以通过``get_current``来获取当前线程的``task_strut``，但是**只能在内核程序中使用**
	- 进程和线程的``task_struct``的区别在于
		- 线程的``task_struct``里部分资源是共享了进程一创建的资源
			- 比如**内存空间，代码段，文件描述符**等
			- 因此Linux中的线程也被称为轻量级线程，其承载的资源比进程``task_struct``的资源少
	- 不管进程是单线程还是多线程，只要开了一个线程，在内核里就相当于多了一个任务，创建了一个``task_struct``，因此在linux中，**内核调度器调度 的对象就是``task_struct``**，一个``task_struct``就对应了一个**任务**
	- 在Linux系统中，任务根据**优先级**和**相应要求**被分为两种
		- **实时任务**：
			- 对系统的响应时间要求很高，需要尽可能快地执行
			- 优先级在``0-99``范围内的任务都算作实时任务
			- [[$red]]==**注**==：优先级值越小，优先级越高
		- **普通任务**
			- 对系统响应时间要求不高
			- 优先级在``100-139``范围内就是普通任务
		- 这里所指的优先级实际是**动态优先级(PR)**，是通过任务的``nice``值动态计算得到的，而`nice`值得取值范围为``-20 ~ 19``，也称**静态优先级(NI)**
		-