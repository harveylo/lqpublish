- 在图形学中，几何往往被分为两类：**隐式几何**和**显式几何**
- # 隐式几何(Implicit Geometry)
	- 核心是**不会直接告诉顶点的位置**，而是使用各种**关系**来描述顶点
		- 例如，一个单位球体**面上的所有的点**可以被表示为一个函数：$x^2+y^2+z^2=1$
	- 推广得到，任何一个$f(x,y,z)=0$的函数都可以被视作一个描述了一空间中一系列的点，这些点构成一个表面
		- ![image.png](../assets/image_1701779389561_0.png){:height 260, :width 433}
		  id:: 656f164f-72b7-408f-af81-edeae274d6ef
	- [[$red]]==**缺点**==：难以从公式去判断实际形状，反过来也难以得到一个实际的复杂形状的隐式表达
	- [[$blue]]==**优点**==：非常容易判断一个点是否符合要求(在或不在表面之上，在物体内部还是外部)
	- ## 代数表面(Algebraic Surfaces)
		- 包括球体，圆环等明显可以使用代数几何表达的形状
		- ![image.png](../assets/image_1701786402248_0.png){:height 163, :width 413}
	- ## Constructive Solid Geometry(CSG)
		- 将一系列的隐式几何表达结合起来得到新的几何形状，典型的包括**3D模型的布尔运算**
		- ![image.png](../assets/image_1701786550240_0.png){:height 169, :width 569}
	- ## 距离函数
		- 对于任何一个物体，不去描述其点的位置，而是给出**任意点到物体的最短距离**，**[[$red]]==距离为0的地方就是物体的表面==**
		- 距离函数的一大用处是可以很方便地做**融合操作**
			- ![image.png](../assets/image_1701787033819_0.png){:height 281, :width 331}
			- 假设有一个矩形在向右移动，上图展示的是实际图像，下图展示的是距离函数地融合，可以看到相较于直接在颜色上做插值，距离函数地融合可以更好的反应中间情况
			- ![image.png](../assets/image_1701787506768_0.png)
		- 距离函数的表达能力很强，但是一般距离函数可能不太能直接写成公式的形式，因此可以采用**[[$red]]==水平集==**的方法来描述距离函数
			- ![image.png](../assets/image_1701788001317_0.png){:height 191, :width 283}
			- 使用水平集还可以比较方便地模拟物理效果
				- ![image.png](../assets/image_1701788307052_0.png){:height 161, :width 291}
	- ## 分形(Fractals)
		- 分型指不断以更小地尺寸重复自身形状地特殊形状
		- ![image.png](../assets/image_1701788431943_0.png){:height 147, :width 584}
		-
- # 显式几何(Explicit Geometry)
	- 直接将所有点的位置记录下来，最典型的就是用各个具体的三角面去描述一个物体
	- 一种不太直观的“显式”表达方式是使用一个从而为平面到三维空间的映射函数来表示所有的点
		- 这种表示是用各种**参数**去表示
		- ![image.png](../assets/image_1701779735812_0.png){:height 255, :width 549}
		- ![image.png](../assets/image_1701780132887_0.png){:height 222, :width 364}
	- 显式表示的**[[$red]]==缺点==**和[[$blue]]==**优点**==同隐式相比刚好相反
		- 表示一个物体变得更简单，但是不好判断一个点在某个物体的内部还是外部
	- ## 点云(Point Cloud)
		- 最简单的一种几何表达方式，就是一堆点(x,y,z)的列表
		- 理论上可以表示任意几何形状，代价是需要使用大量的数据存储
		- 一般来说会转换为网格面(mesh)
	- ## 多边形面
		- 图形中最常使用的方式
		- 往往是四边形或三角形面
		- 比较好进行处理和模拟，但是需要使用到更加复杂的数据结构
		- ### Wavefront Object File(.obj)
			- 图形学中常用的一种模型格式，定义了若干顶点，法向量，纹理坐标和面
			- ![image.png](../assets/image_1701789363630_0.png)
			- 上图的obj文件定义了一个正方体
			- 首先是八个顶点，以`v`开头，后跟xyz坐标
			- 然后是12个纹理坐标，以`vt`开头，后跟uv坐标
			- 接着是八个法向量，以`vn`开头
			- 最后是12个面，以`f`(ace)开头，每个面由三个`顶点index/纹理index/法向量index`来表示
- 在几何表示中，没有什么是**最好**的，只有根据不同的情况选择合适的表达方式
- # 曲面
	- ## 贝塞尔曲线(Bezier Curve)
		- 量化贝塞尔曲线的算法叫做：**de Casteljau算法**
		- 就是不同的控制点之间针对t([0,1])两两插值，得到的点再两两插值，直到得到最终的一个点
		- ![image.png](../assets/image_1701867924669_0.png){:height 276, :width 436}
		- 用**一系列的控制点**来描述曲线，每一个控制点都会描述曲线需要满足的一些**性质**
		- 曲线被要求**一定要通过[[$red]]==起始点==**
		- ### 一般公式
			- 为若干点的线性组合
			- ![image.png](../assets/image_1701871155858_0.png){:height 290, :width 492}
			- 其中，$\begin{pmatrix}n\\i\end{pmatrix}$是二项式系数，及$C_n^k=\frac{n\times (n-1)\times \cdots\times (n-k+1)}{k\times (k-1)\times\cdots\times 1}= \frac{n!}{k!(n-k)!}$
		- ### 性质
			- **一定过起点和终点**
				- 对于三次贝塞尔曲线来说，$\bold{b}(0)=\bold{b}_0;\ \bold{b}(1)=\bold{b}_3$
			- **在起始点的斜率等于当前段的切线**
				- 同样以三次贝塞尔曲线来说：$\bold{b}'(0)=3(\bold{b}_1-\bold{b}_0); \bold{b}'(1) = 3(\bold{b}_3)-\bold{b}_2$
			- **仿射变换性质**(Affine Transformation Property)
				- [[$red]]==回忆==：仿射变换=线性变换+平移变换
					- 即MVP变换中的MV变换
				- 可以直接对控制点做仿射变换然后对得到的点做相同的计算可以得到仿射变换之后的曲线
				- [[$red]]==注意==：投影变换无法维持这一性质
			- **凸包性质**(Convex Hull Property)
				- 画出的贝塞尔曲线一定在控制点所形成的凸包内
					- 凸包是能够包围给定集合形体的**凸多边形**
				- ![image.png](../assets/image_1701872958634_0.png){:height 199, :width 236}
				-
	- ## 逐段贝塞尔曲线(Piecewise Bezier Curves)
		- 随着控制点的增多，贝塞尔曲线逐渐难以控制和预测。
			- 在实际操作中，高阶(控制点较多)的贝塞尔曲线并不常用
			- ![image.png](../assets/image_1702214584941_0.png){:height 248, :width 295}
		- 因此引入了**逐段(Piecewise)**贝塞尔曲线
			- 一般每个独段独立的曲线又**四个**控制点确定
			- ![image.png](../assets/image_1702221568086_0.png){:height 285, :width 278}
		- 两端贝塞尔曲线之间如果要平滑，那么必须切线方向相同且变化速率(斜率大小，导数值)相同
		- ### 逐段贝塞尔曲线的连续性(Continuity)
			- 有几种不同等级的连续性
			- $C^0$**连续**
				- 也就是物理上的连续，上一段的终点等于下一段的起点
				- $\bold{a}_n = \bold{b}_0$
				- ![image.png](../assets/image_1702222375179_0.png){:height 153, :width 336}
			- $C^1$**连续**
				- 切线方向必须相同，且斜率大小也要相同
				- $\bold{a}_n = \bold{b}_0=\frac{1}{2}(\bold{a}_{n-1},+\bold{b}_1)$
				- ![image.png](../assets/image_1702222555407_0.png){:height 189, :width 354}
			- 还有更高的连续要求，但是一般$C^1$连续的效果就足够好了
	- ## 其他曲线
		- ### 样条(Spline)
			- 同样由一系列控制点控制，但是曲线会穿过每一个控制点，并且每一个控制点处都会保持一定的连续性
			- 简而言之就是一条**可控**的曲线
		- ### B-样条
			- **Basis Spline**的简称，即基函数样条
				- 奇函数可简单理解为几个函数加在一起组合成别的函数？
			- 是贝塞尔曲线的**扩展**
				- 贝塞尔曲线的一个缺点是不具备**局部性**
					- 即，如果改变某一个控制点，整个曲线在任何点的形状都会发生改变
					- 这会对曲线的控制和绘制产生不好的影响，尤其是在高阶贝塞尔曲线中
			- B样条的优点就是具有局部性，但是很复杂，本课程不深究
- # 曲面(Surface)
	- ## 贝塞尔曲面(Bezier Surface)
		- 贝塞尔曲面就是在多条贝塞尔曲线中做插值操作得到
		- 贝塞尔曲面由于需要在两个方向做插值，因此在曲面内部也有一个uv坐标系用于做插值
		- ![image.png](../assets/image_1702287340248_0.png){:height 332, :width 554}
- # 网格(Mesh)
	- ![image.png](../assets/image_1702287476859_0.png)
	- 实际上使用最多的表达几何模型的方式，关于网格会有很多操作，上图中，如果使用左起第二张图的网格为基准，那么向右分别是在基准网格上进行了：**网格细分(Mesh Subdivision)**，**网格简化(Mesh Simplification)**和**网格正规化(Mesh Regularization)**
	- 网格操作的一大难点在于，尤其是在网格简化和网格正规化过程中，如何最大程度保留原本的信息
	- ## 网格细分(Subdivision)
		- ![image.png](../assets/image_1702302221416_0.png){:height 216, :width 470}
		- 有很多用于做网格细分的算法
		- ### Loop Subdivision
			- [[$blue]]==Loop是一个人名，和循环无关==
			- **用于三角形网格**的常见算法
			- 一般来说，分为两步
				- 引入更多的三角形
					- 将一个三角形分为四个三角形
					- ![image.png](../assets/image_1702302496782_0.png){:height 78, :width 240}
				- 调整新引入的三角形的位置
					- 针对新旧节点有不一样的调整方式
					- ![image.png](../assets/image_1702302944551_0.png){:height 101, :width 394}
			- **针对新节点的更新方式**
				- 将其坐标调整为：$\frac{3}{8}(A+B)+\frac{1}{8}(C+D)$
				- ![image.png](../assets/image_1702303191487_0.png){:height 200, :width 163}
				- **边界情况：**若新的点只在一条线段上，该线段只属于一个三角形，那么新的坐标为
					- $\frac{1}{2}(A+B)$
			- **针对旧节点的更新方式**
				- ![image.png](../assets/image_1702305496681_0.png){:height 178, :width 198}
				- 定义一个旧顶点的度为其所连接的边的数量，符号为$n$
				- 一个和度有关的分数，用以加权旧顶点和新顶点，$u$
					- 当$n=3$，时，$u=\frac{3}{16}$
					- 否则，$u=\frac{3}{8\times n}$
				- 旧顶点新的坐标为：
					- $(1-nu)\text{original\_position}+u\cdot \text{neighbor\_position\_sum}$
				- **边界情况**：若$n=2$，那么新的坐标为
					- $\frac{1}{8}(A+B)+\frac{3}{4}\text{original\_position}$
		- ### Catmull-Clark细分
			- Loop细分**仅能对三角形面进行细分**，Catmull-Clark**[[$red]]==可以对任何形状的面进行细分==**
			- 此算法将面分为两种面，**Quad Face(四边形面)**和**Non-Quad Face(非四边形面)**，其含义为字面意思
			- 同时将点也分为两类点，即**奇异点(Extraodinary Vertex)**，和非奇异点，**[[$red]]==所有度不为4的点都是奇异点==**
			- ![image.png](../assets/image_1702798066155_0.png){:height 243, :width 359}
			- **细分步骤**
				- ![image.png](../assets/image_1702798978701_0.png){:height 159, :width 227}
				- 在每一个面中加一个点
				- 每条边的中点处加一个点
				- 将每一个面中新加的点和其边上的中点相连
			- **观察**
				- 每一次细分操作之后，所有的非四边形面都会消失
				- 在每一个原来的非四边形面内部都会引入一个新的奇异点
					- 如果继续细分，不会引入新的奇异点
					- 即，奇异点数只会在第一细分时增加
				- 本来为奇异点的点还是奇异点
			- **更新顶点位置**
				- ![image.png](../assets/image_1702799115418_0.png){:height 253, :width 413}
	- ## 网格简化
		- ![image.png](../assets/image_1702799593799_0.png){:height 166, :width 375}
		- 在较远处看，较低复杂程度的几何模型，效果相差不会太大
		- ### 边坍缩(Edge Collapsing)
			- ![image.png](../assets/image_1702799806827_0.png){:height 160, :width 410}
			- 把相近的顶点“捏”到一起
			- 边坍缩会导致一些问题，其中最主要的问题就是随着坍缩的加深，几何形变会越来越严重
			- **二次误差度量(Quadric Error Metrics)**就是用于衡量几何形变大小的一个标准
				- 新形成的节点不能单纯地使用平均来确定其位置，不然就会导致二次误差过大
			- 在实际操作中，**应该让新的节点和原来存在的平面的距离平方之和最小化**
				- ![image.png](../assets/image_1702800272728_0.png){:height 172, :width 432}
			- **实际算法**
				- 在进行边坍缩时，遍历每一个边，并计算所过将该边坍缩到其中点所产生的二次误差，选择二次误差最小的边进行坍缩，并更新那些受影响的边的二次误差
				- 实际是一个贪心算法，但是效果还不错
- # 阴影(Shadow)
	- 在光栅化下，阴影实际上并不好做，因为着色是针对每个 像素点的独立过程
	- 但业界还是找到了在光栅化下做阴影的方法，即**[[$red]]==Shadow Mapping==**
	- Shadow Mapping本是上是在**图像空间**下的一种方法
		- 即生成阴影不需要知道物体实际的几何信息
		- 如果不经处理，会产生明显的走样现象
	- **[[$red]]==核心思想==**
		- 如果一个点不再阴影中，那么这个点**必须同时能被光源和摄像机看到**
	- 经典的shadow mapping**只能处理点光源**
	- ## 算法步骤
		- ### 第一步，从点光源生成深度图
			- ![image.png](../assets/image_1702802978860_0.png){:height 236, :width 211}
			- 一点光源作为摄像机左右一次光栅化，看能看到哪些点，哪些点会被挡住(Z-buffer)
			- **把点光源能看到的点的深度记下来**
		- ### 第二步，从视角处进行渲染
			- ![image.png](../assets/image_1702803048695_0.png){:height 294, :width 288}
			- 视角中每看到一个点，将其还原到光源的视角空间下的图像坐标，得到相关坐标在光源深度图中的**深度**
			- 然后实际计算该点到光源的**距离**
			- 如果**距离和深度图中的深度一致**，那么说明该点是可见的，不再阴影中
				- ![image.png](../assets/image_1702803313509_0.png){:height 250, :width 293}
			- 否则就说明在阴影中，需要进行相应处理
				- ![image.png](../assets/image_1702803329721_0.png){:height 201, :width 312}
	- ## Shadow Mapping的问题
		- ### 数值精度问题
			- 由于数值精度问题，计算出的距离和深度往往都不够精确，导致无法很好判断一个点是否在阴影中
		- ### Shadow Map分辨率问题
			- 阴影渲染本质上是在渲染时针对每一个点光源额外渲染了一张图，因此这张深度图的分辨率本身也会印象阴影的质量
			- 如果分辨率过低，会导致阴影出现锯齿；若分辨率过高则会导致性能问题
		- ### Hard Shadows
			- 仅能渲染点光源的阴影，而且边缘非常明确
				- ![image.png](../assets/image_1702804499035_0.png){:height 275, :width 357}
				- 如果光源本身真的只是一个点，本身没有体积大小，那么形成硬阴影是可能的
			- 但实际上，由于光源本身有大小，且存在环境中光散射的情况，真实的阴影不应该边界如此清晰锐利
				- ![image.png](../assets/image_1702804550271_0.png){:height 265, :width 343}
				- 完全看不到阴影的地方叫做**本影(Umbra)**，看得到部分光源的地方叫做**半影(Penumbra)**
					- ![image.png](../assets/image_1702804571224_0.png){:height 214, :width 489}
			-