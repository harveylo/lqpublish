- 参看：[浅谈地址无关代码](https://www.jianshu.com/p/c67a5b69204e)
- position-independent code**(PIC)**
- 又称position-independent executable**(PIE)**
- # 程序的加载与动态链接
	- ## 静态链接与动态链接
		- 程序的代码一般不可能在一个源文件中实现，例如一个简单的helloworld程序调用的库函数printf
		- 对于这种文件的调用一般有两种方式
			- **连接过程中加入静态库**
				- 例如libc-a-b-c.a
				- 实际上就是将静态库文件和自编写的程序连接在一起，生成一个可执行文件
				- 使用静态库链接完成得到的可执行文件[[$blue]]==无需外部依赖==，因为实际上调用的外部代码已经编译整合到可执行文件中
				- 但是整合到可执行文件当中就意味着最终得到的可执行文件[[$red]]==体积会更大==
			- **执行时动态调用动态库**
				- 例如libc-a-b-c.so
				- 生成的可执行文件并不包含库文件及其中代码
				- [[$red]]==具有外部依赖==，缺少动态库则无法运行
				- 在执行期间，可执行文件被加载进虚拟内存时，可执行文件涉及到的动态库也被加载进内存
				- [[$blue]]==体积更小==
				- 可能会导致一些版本接口改变造成的[[$red]]==依赖性问题==
			- ![](https://upload-images.jianshu.io/upload_images/4312211-2dc7eafa48b59753.png){:height 274, :width 418}
		- 系统中**大部分程序**都需要一些特定库，当系统运行一百个进程时，若这些进程都会执行一些库中的代码，则
			- 如果使用[[$red]]==静态库==，则这些库中的代码会被整合到100个程序的代码当中，这些程序被加载到内存中执行时，则这些库函数代码也会被加载到内存中100份，严重消耗内存资源
			- 而使用[[$blue]]==动态库==，则只需要将这些库函数载入进内存一次，当库函数被调用时，直接转移到被载入的库函数处执行，节省内存空间
	- ## 从编译到链接
		- 可参考 [[gcc编译过程简介]]
		- ![](https://upload-images.jianshu.io/upload_images/4312211-0e7a69640d763bec.png)
		- 如果不使用静态库在链接时整合到可执行文件中，而是在执行时动态加载库文件，则会出现实际执行过程中控[[$red]]==制流转换的地址问题==
		- ```
		  printf("IOLI Crackme Level 0x00n");    
		  ...
		  .text:0804842E       29 C4                     sub     esp, eax
		  .text:08048430       C7 04 24 68 85 04 08      mov     dword ptr [esp], offset format ; "IOLI Crackme Level 0x00n"
		  .text:08048437       E8  04 FF FF FF           call    _printf
		  ...
		  ```
		- 例如，在上面的汇编代码中，0x08048437处call了一个printf，这明显是涉及到地址的
			- 而动态库的API地址是装在之后才确定的(不过一些重要的动态库，如ntdll，几乎有着固定的装载地址)
			- 那么如何才能在执行时确定要调用的库函数的地址？
- # 地址无关代码
	- ## 静态共享库
		- 最符合直觉的想法是：在汇编代码生成之前确定API的地址
			- 这意味着每个库的装载地址都需要预先确定
		- 在早期，曾经存在过一种名为**静态共享库**的解决方案
		- 将模块统一交给操作系统管理，使用的库会被加载到某个**固定的地址**
			- 这样便可以在编译时确定调用函数的地址
		- 该方案[[$red]]==存在的问题==：
			- 库在后续升级中需要严格保证每个函数的地址不会发生变化，不能有api的删减，否则会导致依赖于旧版本的已生成的可执行文件因为函数调用地址对不上而无法运行
			- 自己编写的库文件很难以共享库的方式被使用
		- [[$blue]]==**解决方式**==
			- 不再强制要求在固定地址装载
			- 在模块的装在地址确定之后[[$red]]==再修复函数引用的地址==
			- 但是再没有开启[ASLR(Address space layout randomization)](https://zh.wikipedia.org/zh-cn/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5)的情况下，可执行文件的模块装载地址是固定的
				- Windows下地址为0x004000000
				- Linux下位0x00804000
	- ## 装载时重定位
		- 对其它模块的函数的引用在链接时只填写函数相对于其模块起始地址的相对地址，装载时模块及地址确定之后再修改为相对地址+基地址
			- 例如，foo函数相较于其所在模块a起始地址的偏移是0x100，则先在连接阶段填入0x100
			- 当a模块装在后确定基地址为0x60000后，修改所有调用foo处的地址为0x60100
		- 此方案至今仍然广泛使用，但是存在[[$red]]==指令共享时无法正常使用==的问题
			- 为什么会出问题[参看](https://blog.csdn.net/parallelyk/article/details/42747239)
			- 简单来说，装载时重定位仍然会把库函数整合到可执行程序的地址空间中，只不过这个过程从编译阶段推迟到了装载阶段
			- 而只要是重定位，那么库函数的指令肯定也会被修改，因为所有的操作都是在当前正在执行的进程的地址空间下完成的，库函数中涉及到内存操作和跳转指令的指令也都会需要修改为当前地址空间下的绝对地址
			- 所以该方案实际上只解决了每个进程都要拷贝一份库函数代码的问题，没有解决多个进程同时共享同一个代码段的需求。
				- 实际操作流程大概是：库函数中的代码指令被加载的物理内存中->有一个调用了该函数的进程被装载->执行重定位，库函数的指令会被修改到当前进程的地址空间下->该进程执行到调用该函数时，跳转到物理地址中的库函数->该进程执行完毕->另一个调用该函数的进程被装载->再一次执行重定位，函数指令被修改
	- ## 地址无关代码
		- TODO 把这篇文章看完
		-
	-
	-