- 参看：[浅谈地址无关代码](https://www.jianshu.com/p/c67a5b69204e)
- position-independent code**(PIC)**
- 又称position-independent executable**(PIE)**
- # 程序的加载与动态链接
	- ## 静态链接与动态链接
		- 程序的代码一般不可能在一个源文件中实现，例如一个简单的helloworld程序调用的库函数printf
		- 对于这种文件的调用一般有两种方式
			- **连接过程中加入静态库**
				- 例如libc-a-b-c.a
				- 实际上就是将静态库文件和自编写的程序连接在一起，生成一个可执行文件
				- 使用静态库链接完成得到的可执行文件[[$blue]]==无需外部依赖==，因为实际上调用的外部代码已经编译整合到可执行文件中
				- 但是整合到可执行文件当中就意味着最终得到的可执行文件[[$red]]==体积会更大==
			- **执行时动态调用动态库**
				- 例如libc-a-b-c.so
				- 生成的可执行文件并不包含库文件及其中代码
				- [[$red]]==具有外部依赖==，缺少动态库则无法运行
				- 在执行期间，可执行文件被加载进虚拟内存时，可执行文件涉及到的动态库也被加载进内存
				- [[$blue]]==体积更小==
				- 可能会导致一些版本接口改变造成的[[$red]]==依赖性问题==
			- ![](https://upload-images.jianshu.io/upload_images/4312211-2dc7eafa48b59753.png){:height 274, :width 418}
		- 系统中**大部分程序**都需要一些特定库，当系统运行一百个进程时，若这些进程都会执行一些库中的代码，则
			- 如果使用[[$red]]==静态库==，则这些库中的代码会被整合到100个程序的代码当中，这些程序被加载到内存中执行时，则这些库函数代码也会被加载到内存中100份，严重消耗内存资源
			- 而使用[[$blue]]==动态库==，则只需要将这些库函数载入进内存一次，当库函数被调用时，直接转移到被载入的库函数处执行，节省内存空间
	- ## 从编译到链接
		- 可参考 [[gcc编译过程简介]]
		- ![](https://upload-images.jianshu.io/upload_images/4312211-0e7a69640d763bec.png)
		- 如果不使用静态库在链接时整合到可执行文件中，而是在执行时动态加载库文件，则会出现实际执行过程中控[[$red]]==制流转换的地址问题==
		- ```
		  printf("IOLI Crackme Level 0x00n");    
		  ...
		  .text:0804842E       29 C4                     sub     esp, eax
		  .text:08048430       C7 04 24 68 85 04 08      mov     dword ptr [esp], offset format ; "IOLI Crackme Level 0x00n"
		  .text:08048437       E8  04 FF FF FF           call    _printf
		  ...
		  ```
		- 例如，在上面的汇编代码中，0x08048437处call了一个printf，这明显是涉及到地址的
			- 而动态库的API地址是装在之后才确定的(不过一些重要的动态库，如ntdll，几乎有着固定的装载地址)
			- 那么如何才能在执行时确定要调用的库函数的地址？
- # 地址无关代码
	- ## 静态共享库
		- 最符合直觉的想法是：在汇编代码生成之前确定API的地址
			- 这意味着每个库的装载地址都需要预先确定
		- 在早期，曾经存在过一种名为**静态共享库**的解决方案
		- 将模块统一交给操作系统管理，使用的库会被加载到某个**固定的地址**
			- 这样便可以在编译时确定调用函数的地址
		- 该方案[[$red]]==存在的问题==：
			- 库在后续升级中需要严格保证每个函数的地址不会发生变化，不能有api的删减，否则会导致依赖于旧版本的已生成的可执行文件因为函数调用地址对不上而无法运行
			- 自己编写的库文件很难以共享库的方式被使用
		- [[$blue]]==**解决方式**==
			- 不再强制要求在固定地址装载
			- 在模块的装在地址确定之后[[$red]]==再修复函数引用的地址==
			- 但是在没有开启[ASLR(Address space layout randomization)](https://zh.wikipedia.org/zh-cn/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5)的情况下，可执行文件的模块装载地址是固定的
				- Windows下地址为0x004000000
				- Linux下位0x00804000
	- ## 装载时重定位
		- 对其它模块的函数的引用在链接时只填写函数相对于其模块起始地址的相对地址，装载时模块及地址确定之后再修改为相对地址+基地址
			- 例如，foo函数相较于其所在模块a起始地址的偏移是0x100，则先在连接阶段填入0x100
			- 当a模块装在后确定基地址为0x60000后，修改所有调用foo处的地址为0x60100
		- 此方案至今仍然广泛使用，但是存在[[$red]]==指令共享时无法正常使用==的问题
			- 为什么会出问题[参看](https://blog.csdn.net/parallelyk/article/details/42747239)
			- 简单来说，装载时重定位仍然会把库函数整合到可执行程序的地址空间中，只不过这个过程从编译阶段推迟到了装载阶段
			- 而只要是重定位，那么库函数的指令肯定也会被修改，因为所有的操作都是在当前正在执行的进程的地址空间下完成的，库函数中涉及到内存操作和跳转指令的指令也都会需要修改为当前地址空间下的绝对地址
			- 所以该方案实际上只解决了每个进程都要拷贝一份库函数代码的问题，没有解决多个进程同时共享同一个代码段的需求。
				- 实际操作流程大概是：库函数中的代码指令被加载的物理内存中->有一个调用了该函数的进程被装载->执行重定位，库函数的指令会被修改到当前进程的地址空间下->该进程执行到调用该函数时，跳转到物理地址中的库函数->该进程执行完毕->另一个调用该函数的进程被装载->再一次执行重定位，函数指令被修改
	- ## 地址无关代码
		- DONE 把这篇文章看完
		- 将需要重定位的部分指令放入数据中，每个进程都会有一份自己的需要重定位的指令
		- ### 模块内部函数调用或跳转
			- 被调用的函数与调用者处于同一模块，所以两者之间相对位置是固定的，可以使用相对地址寻址
			- 无需重定位
			- ```
			  0x8048349   <foo>:
			  ...
			  .init:080482FE   E8 81 00 00 00     call    sub_8048384
			  ...
			  ```
			- call调用的并非是绝对地址，而是当前的pc地址加上0x81的地址
		- ### 模块内部数据调用
			- 因为仍然在同一个模块内部，还是根据当前pc值进行相对寻址
			- 但是由于没有直接相对当前pc值进行访存的指令，所以相对跳转会复杂一点
			- elf提供了一个`__i686.get_pc_thunk.xx` 函数，用于解决该问题
			- ```
			  .text:08048515 __i686_get_pc_thunk_bx proc near        ; CODE XREF: __libc_csu_init+8↑p
			  .text:08048515                 mov     ebx, [esp+0]
			  .text:08048518                 retn
			  .text:08048518 __i686_get_pc_thunk_bx endp
			  ```
			- 由于 `call` 指令等效于 `push $PC` ，所以 `mov ebx, [esp+0]` 相当于取 `call <__i686.get_pc_thunk.bx>` 指令的下一条地址指令到ecx，此时就可以通过ecx加上偏移，完成对模块内部数据的寻址。
			- ```
			  .text:080484A8                 call    __i686_get_pc_thunk_bx
			  .text:080484AD                 add     ebx, 1B47h
			  .text:080484B3                 sub     esp, 1Ch
			  .text:080484B6                 call    _init_proc
			  .text:080484BB                 lea     eax, (__CTOR_LIST__ - 8049FF4h)[ebx]
			  .text:080484C1                 lea     edx, (__CTOR_LIST__ - 8049FF4h)[ebx]
			  ```
			- 程序调用 `call __i686_get_pc_thunk_bx` 后对ebx（即0x080484AD的地址）进行了加0x1B47的操作，也就是加上了偏移量。之后两条 `lea` 指令则是通过一些常量结合先前的地址完成偏移量计算，最终完成访存操作。
		- ### 模块间数据访问
			- 只有在被调用的代码所在模块装载完成后才能获得其基地址
			- 在调用者的数据段中，会存有一个记录其他模块数据地址的**GOT表**
			- 需要访问其他模块的数据时，根据got表来查询具体地址，然后访问
			- 放在数据段的原因是，该表往往需要在其他模块完成载入时被修改，而一般来说，代码段是不允许被修改的
			- ![](https://upload-images.jianshu.io/upload_images/4312211-a7c781e536704aee.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
		- ### 模块间的跳转与调用
			- 解决方法和上一小节类似，区别在于上一小节是对从got表中获得的地址进行访存，而调用是call从got表中获得的地址
			- ```
			  call        494 <__i686.get_pc_thunk.cx>
			      add         $0x118c,%ecx
			      mov         0xfffffffc(%ecx),eax
			      call        *(%eax)
			  ```
			- 简单，但是存在[[$red]]==性能浪费==，实际上elf采用另一种近似原理的方案
- # 延迟绑定
	- GOT表需要在模块被装在后，逐一初始化GOT表表项
	- 有很多模块中的函数可能在程序的整个执行过程中都不会被调用，因此初始化这些函数的表项会造成浪费
		- 引入**[[$blue]]==延迟绑定==**技术来解决此问题
	- 使用**PLT(Procedure Linkage Table)**实现延迟绑定
		- 当第一次访问相应函数时，才填入GOT表项
	- 编译器不再直接编译出访问GOT表的语句，而是通过plt来完成函数跳转，根据情况选择是否填入GOT表或直接访问GOT表
	- ![从PIL到GOT到真实地址](https://pic3.zhimg.com/v2-0cbf316c2275f712c440f0f43b3bc1be_r.jpg)‘
	- 某一函数尚未被调用时，got表中对应的地址实际上是一个动态运行时地址解析函数
	- 第一次调用时，实际先执行的是该地址解析函数，执行之后，got表中会填入真实地址
	- 后续调用会直接跳转到该函数的地址执行