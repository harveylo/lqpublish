- 解决代码耦合问题的核心原则之一是信息隐藏
- 只暴露出需要依赖的东西(接口)
- 这样做可以
	- 降低测试成本
	- 提高安全性
	- 方便代码分析工具和重构工具对代码进行更精准的引用分析
- **依赖管理**和使用，发布库函数息息相关，包括
	- 如何控制最小化依赖
	- 如何发布API
	- 如何获取他人API
	- 对依赖进行顶追溯和控制，包括解决依赖冲突
- 信息隐藏和依赖管理对于软件开发十分重要
- 现代编程语言大都提供了丰富的信息隐藏手段和依赖管理工具，例如
	- 不同级别的代码符号可见性控制
	- 显式的API导入导出能力
	- 模块化构建
	- 包管理工具链
- 而C/C++语言出现年代久远，因此历史包袱重，对符号隐藏和依赖管理的特性和工具支持演进慢
- 但是C/C++在实践中发展出了一些相关技巧，且已被许多优秀的C/C++项目广泛使用
- # 代码符号隐藏
	- C语言中全局变量和函数的符号是**默认外部可访问**的
	- 知道一个全局变量或函数声明则可以在当前的编译单元中直接使用
		- 连接器会在连接期间帮助**跨编译单元**寻找符号并连接
	- ## 全局可访问造成的问题
		- ### 增加了代码符号冲突几率
			- 为了在全局可见性下避免符号冲突，在大型C项目中所有全局变量和函数名必须加上**子系统名**或**模块名**
				- 导致代码不够简洁且二进制文件将占用更多空间
		- ### 造成间接隐式依赖
			- ``extern``关键字可以直接绕过头文件，引用其他编译单元本不想暴露的符号
			- 导致潜在的安全风险
			- 对``extern``不加控制的项目，依赖关系往往最终会乱套
			- ``extern``还会造成重复声明，破坏了**DRY**(don't repeat yourself)原则
	- ## 代码符号隐藏的原则
		- ### 对于C
			- #### 尽量避免使用``extern``关键字
				- 如上文所述，``extern``关键字可能造成各种问题
				- 只有在**极少数**情况下，``extern``关键字所带来的收益大于其潜在风险
					- 明确要链接某些**第三方**且**没有头文件**的**二进制库**
					- 调用**汇编编写**的函数
					- 访问**编译器/链接器**自动生成的符号
					- 等
			- #### 多使用``static``关键字
				- 应该**在任何可以使用``static``关键字的地方使用它**，也是C语言中**仅有的**用于隐藏符号的手段
				- ``static``的作用
					- 在**函数内部**，``static``标识变量不在栈上而在全局静态区
					- 对于**全局变量**和**函数**，标识对应的符号可见性仅在其所在的编译单元内部
				- 尽量多使用``static``能显著改善设计，得到符合**Modular C**风格的设计
					- 将所有无需暴露的函数和状态(全局变量)通过``static``隐藏到编译单元内部
					- 将API生命放到头文件中
		- ### 对于C++
			- #### 尽可能多的使用``private``
			- #### 尽可能多地利用命名空间来管理符号
				- ``namespace``可以对符号分类，将其控制在独立的命名空间中
				- 但是某一个命名空间中的所有符号都是可见的，无法在命名空间内布进行符号隐藏
				- 可以使用**匿名命名空间**来**隐藏符号**
					- 在匿名命名空间中地符号都是**不可导出**的，仅在本编译单元内部可见
					- 作用类似于C的``static``
				- ```
				  namespace {
				    struct Port {
				        // ...
				    };
				  - Port ports[MAX_NUM];
				  - unsigned int getRateOf(const Port& port) {
				        // ...
				    }
				  }
				  - unsigned int getPortRate(unsigned int portId) {
				    // ...
				  }
				  ```
			-
				-