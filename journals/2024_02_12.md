- 轨迹语义有[[$red]]==**大问题**==
	- call it as **visibility problem**
	- eval函数的定义仅在本地，展开时很多控制流语句也依赖于eval函数的返回值
	- 目前eval函数定义在本地进程的trace上，**看不到其他进程对于全局变量的改变**，**[[$red]]==严重影响对于控制语句的展开==**
		- 以peterson 算法为例，根本看不带另一个线程对于turn和flag的更改。
	- 并发组合的本意是将已经展开好的trace简单穿插，其本来也是定义在轨迹上的
	- **目前想到的解决方案**
		- 修改eval和内存的定义
			- 目前对于内存的定义是一连串写记录，直接改成数组或者说hashmap
			- 写操作直接作用于这个数组，也不再需要繁杂的定义在trace上的eval函数
			- **缺点**：
				- 感觉会不太自洽
				- this array or hashmap just comes from nowhere
		- 对轨迹语义大改，主要是展开顺序
			- 程序的并发操作先于顺序组合操作
			- 并发穿插时，随机选择某个程序执行，获取其第一个trace，然后放入总trace中
				- eval函数将这个到目前为止的总trace当作输入，而不是本地进程单独的trace
			- 简而言之，先穿插，再顺序组合
			- **[[$red]]==缺点==**
				- 工作量大
				- 很多地方要改
				- 可能直接动摇根基
		- 不管，使用代数语义
			- 代数语义的定义稍微模糊一些，可以说代数语义就是先穿插的，每次选择一个程序的首规范式来执行
			- 也可以说代数语义没有严格定义变量值的读取
			-