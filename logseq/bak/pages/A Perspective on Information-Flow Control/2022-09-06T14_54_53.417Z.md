- # Introduction
	- ## Attacker
		- ### program centric attacker
			- **aware of：**
				- public observable outputs
					- e.g. public outputs
				- **[[$red]]==source code==**
			- **have control of**
				- public input
		- ### web attacker
			- an honest user who runs a trusted browser on a trusted machine and that the attacker is an owner of malicious web sites that the user might be accessing
			- 类似钓鱼网站
	- ## Policy languages
		- The ***Policy Language*** 描述可能的信息加密方式和不同的加密方式之间的关系
			- 例如：一种加密中的信息如何流到另一种
			- 学界主流（到2012年）使用一种**lattice model**来描述policy language
		- ***semantic characterization*** 使用编程语言的语义去描述policy language的含义
			- noninterference的一种变体
- # Confidentiality
	- information flow security的关键在于**preservation of confidentiality of information**
	- ## Noninterference
		- ### Sources of information flow
			- 有两种主要的IF源
				- **显式流（explicit flow）**
					- 对于秘密的直接拷贝（一个变量的值被复制给了另外一个变量）
					- 典型的例子：copy the value of a secret (or high) variable h into a public (or low) variable l
				- **隐式流**
					- 出现在控制流被秘密值影响的时候
					- 例子：秘密h的值被隐式地赋给了l
						- ``l = false; if h then l = true else skip``
			- 非形式化地来说，当一个程序的public outputs不取决于secret input的值时，该程序是满足noninterference的
			- 从程序运行的角度来说，如果一个程序在不同的secret输入下，保持公共值不变运行，则公共输出应该保持不变
		- ### general noninterference
			- **记法**
				- $c$，某些编程语言的一些指令
				- $<c,E>\Downarrow o$，一个***赋值关系（evaluation relation）***，读取$c$并且在环境$E$下执行，得到一些可观测的行为$o$
				- $\sim$ ，***low equivalence***，environment之间的关系，表示环境之间的公共部分相同
				- $\simeq$，indistinguishablility，
				- $NI(c) = \forall E_1,E_2\cdot E_1 \sim E_2 \wedge <c,E_1>\Downarrow o_1 \Longrightarrow \exists o_2\cdot <c,E_2>\Downarrow o_2\wedge o_1\simeq o_2$
					- 若一个程序$c$满足*noninterference*，则记作$NI(c)$
			- **Termination-insensitive & termination-sensitive noninterference**
				- [[$blue]]==bath-job program==：一个在某一环境下开始运行，最后要么发散要么产生一个新环境的程序
					- batch-job的attacker的攻击者模型设定为：能够检视最终环境的公共部分
					- 一个简单的batch-job while language：
						- ![image.png](../assets/image_1662302387984_0.png)
						- **语义**
							- big-step operational semantics
								- ![image.png](../assets/image_1662304254281_0.png)
							- $v$：所有可能值的集合
							- $\gamma$：variable environment，一个从变量名到值的映射
							- $E$：环境，包含一个variable environment
							- $E[x]$：在环境$E$中获取变量$x$的值
							- $E[x\mapsto v]$：在环境$E$中更新变量$x$的值为$v$
								- $E[x \mapsto v][x] = v, and\ E[x \mapsto v][y] = E[y] for y \ne x$
							- 一个evaluation relation是一个$E, x$的二元函数，输出是一个值
								- 记作$<E,x>$
								- ![image.png](../assets/image_1662303449156_0.png)
								- $\star$表示二元算术运算
								- $<c,E_1> \Rightarrow E_2$，对于$c$的evaluatoin即产出一个新的环境
				- [[$blue]]==Security policy language for the batch-job while language==
					- 使用一种格来描述
					- security labels
						- $\sigma ::= H | L$
						- H和L对应了两种安全等级，secret和public
						- 有$H>L$，即secret永远不能成为public，但是反向的信息流动是允许的
					- $\Gamma$是一个**variable security maps**，将变量名映射到security labels
						- 映射到$L$的变量只能包含公共信息，即公共变量
						- 映射到$H$的变量可以包含secrets，即秘密变量
				- [[$blue]]==Low equivalence==
				  collapsed:: true
					- 环境之间的low equivalence实际上是要求被标记为公共的部分要相同
					- 对于low equivalence的公式化定义
						- **对于变量：**
							- ![image.png](../assets/image_1662365845321_0.png){:height 91, :width 273}
							- 如果两个变量安全等级是$L$，则必须要值相同它们才是low equivalence的
							- 任何两个被标记为secret的变量都是low equivalence的
						- **对于变量环境**
							- ![image.png](../assets/image_1662366232554_0.png)
								- 对于一个variable security maps$\Gamma$，则对于任何在其定义域中的变量$x$，两个variable maps对其的赋值都是low equivalence的，则该两个variable maps在该variable security maps下是low equivalent
								- 所以两个low equivalent的变量环境必须包含同一个variable security maps的所有变量，并且所有公共的变量都必须包含同样的值
						- **对于环境**
							- 如果在某一个变量映射（variable security maps）下，两个环境中所包含的变量环境是low equivalent的，则这两环境也是low equivalent的
				- [[$blue]]==Termination-insensitive vs. termination-sensitive noninterference==
				  collapsed:: true
					- 对于attacker来说，它在目前的模型中能够检视的是程序执行之后最终环境中的公共部分
					- 那么程序的divergence是否是能够被观测的公共部分成为了区分termination-insensitive和termination-sensitive的标准
					- 判断一个程序$c$是否发散的语义定义很简单：如果$c$在环境$E_1$中发散则$\neg \exists E_1 \cdot \langle c,E_1\rangle \Rightarrow E_2$
					- **记法**：
					  collapsed:: true
						- $\diamond$：发散
						- $o$：可观测的行为
						- 由于假设attacker能观测到的行为就是程序执行后的环境，因此有：
							- ![image.png](../assets/image_1662368554469_0.png){:height 104, :width 231}
						- 如果divergence也是可观测的行为，则有
							- ![image.png](../assets/image_1662368584828_0.png){:height 93, :width 258}
					- **Termination-Insensitive noninterference (TINI)**
					  collapsed:: true
						- 在该NI下发散无法观测，所以发散和任何终止的输出都是indistinguishable的
						- TINI的indistinguishability的定义如下
							- ![image.png](../assets/image_1662371387409_0.png){:height 72, :width 343}
						- 两个环境必须在某一个变量映射下是low equivalent的才能是indispensable的
						- 一个程序$c$满足TINI记作$TINI(c)$
						- $TINI(c)=\forall E_1,E_2\cdot E_1 \sim_\Gamma E_2 \wedge \langle c, E_1\rangle \Downarrow o_1 \Rightarrow \exists o_2\cdot \langle c,E_2\rangle \Downarrow o_2 \wedge o_1 \simeq_{TI} o_2$
						- 如果两次执行中任意一次执行发散则直接满足TINI
						- 如果两次执行都终止，则要求最终环境满足low equivalence
						- 对于batch-job program来说，满足TINI能达到比较良好的安全性，不然还是会在每一次程序执行中泄露至多1 bit的信息
					- **Termination-sensitive noninterference (TSNI)**
						- 对于两个low equivalent environment，如果程序在其中一个环境中正常终止，那么就必须要在另一个环境中也正常终止且终止的最终环境要满足low equivalence
						- 改变indistinguishability的定义便足以定义TSNI的语义
							- ![image.png](../assets/image_1662383365300_0.png){:height 94, :width 317}
						- 一个程序$c$满足TSNI记作$TSNI(c)$
						- $TSNI(c)=\forall E_1,E_2\cdot E_1 \sim_\Gamma E_2 \wedge \langle c, E_1\rangle \Downarrow o_1 \Rightarrow \exists o_2\cdot \langle c,E_2\rangle \Downarrow o_2 \wedge o_1 \simeq_{TS} o_2$
					- **Classical formulation ofbatch-job noninterference**
						- 对于一个batch-job程序的更为经典的noninterference定义是，程序在任何两个满足low equivalence的环境下执行后产生的新环境都要满足low equivalence
						- 经典termination insensitive noninterference：
							- $TINI_\Gamma = \forall E_1, E_2 \cdot E_1\sim_\Gamma E_2 \wedge\langle c,E_1\rangle \Rightarrow E_{11} \wedge \langle c,E_2\rangle \Rightarrow E_{22}\Longrightarrow  E_{22}\sim_\Gamma E_{11}$
							- 对于两个有下一状态的满足low equivalence的环境，所以是termination insensitive的
						- 经典termination sensitive noninterference：
							- $TSNI_\Gamma = \forall E_1,E_2 \cdot E_1\sim_\Gamma E_2\wedge \langle c,E_1\rangle E_11 \Longrightarrow \exists E_22 \cdot \langle c,E_2\rangle \rightarrow E_22\wedge E_{11}\sim_\Gamma E_{22}$
							- 对于任何两个满足low equivalence的环境，如果其中一个环境下的执行有下一个环境（terminated），那么另外一个环境下的执行也必须终止且终止环境满足low equivalence
						- 这两种表达实际上和之前的两种表达没有区别，只不过之前的两种表达引入了indistinguishability的概念， 使得定义更加好理解
				- [[$blue]]==From termination to progress==
					- 之前对于attacker能力的假设是只能检视源代码和最终程序执行完成之后最终环境
					- 如果让attacker获得能够检视中间步骤的能力，则哪些满足TINI和TSNI的程序会瞬间泄露秘密
					- 因此需要一种能够建模互动程序中的中间步骤观测的语义
				- [[$blue]]==Progress-insensitive vs. progress-sensitive noninterference==
					- 增加对于while language的input 和 output的定义
					- 攻击者现在能够检视一个程序的公共output
				- [[$blue]]==While language with input and output==
					- 新增加的指令：$in_\sigma x$，$out_\sigma x$
					- $\sigma$指明了输入输出信息是public还是secret
					- 之前单纯只包含一个变量环境$\gamma$的环境$E$扩展为一个三元组$(\gamma,\iota,\omega)$，后两者分辨代表输入值集合和输出值集合
					- $\dot{v}$：一个decoration，指示一个变量或nothing
					- Big step的操作语义中一步到位得出最终环境的evaluation被分割为了两种：
						- **terminating evaluation**：该evaluation种的c可以一步完成，执行之后程序就终止：
							- $\langle c,E_1 \rangle \overset{\dot{v}}{\rightarrow} E_2$
						- **nonterminating evaluation**：c不是能够一步完成的，执行之后会有剩余的指令：
							- $\langle c_1,E_1\rangle \overset{\dot{v}}{\rightarrow} \langle c_2, E_2\rangle$
						- 两种evaluation箭头上的decoration表示可能被观测到的行为
					- 改进后的语义：
						- ![image.png](../assets/image_1662395277761_0.png){:height 343, :width 442}
						- **[[$red]]==个人理解：==**input不断消耗input池中的值，output不停地向output结果中append output
						-
							-
					-
-