- # 左值右值引用相关
	- ## [[$red]]==一个函数返回左值引用和右值引用有什么区别？==
		- [[$red]]==直接返回某类型值是否都会引起编译器的复制省略优化(copy elision)?==
			- 若函数返回类型会变量而非引用和指针，且实际返回时返回了一个在自己栈帧上分配的本地变量或临时变量，大多数情况下编译器都会尝试进行进行RVO。且如果返回对象在编译时就可确定，则大概率会进行RVO
			- RVO的**原理**：直接在调用者的栈帧上分配内存，而不会先在函数的栈帧中初始化一次，再通过拷贝构造函数复制到调用者的栈帧中
			- 在以下情况**编译器大概率不会进行RVO**
				- 函数的具体返回值在运行时动态确定(条件判断或三元运算符如return b?a:c)
				- 函数的返回类型是基类或虚基类
				- 函数的返回类型是数组类型([[$red]]==?==)
				- 函数的返回类型是``std::intitializer_list``[[$red]]==(?)==
				- 函数的返回类型是非class类型(基础类型，枚举，void等)
		- ### 一些猜想，个人理解和实验结果
			- [[$red]]==实验结果无法排除UB和platform-specific的可能性==
				- 去啃相关手册可能能够排除[[$red]]==(?)==
			- **实验平台**
				- CPU：i7-1165G7
				- 系统：
					- linux版本：5.19.0-35-generic
					- ubuntu版本：22.04
				- 编译器：(Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0
			- 函数返回值都是右值[[$red]]==(?)==
				- [[$red]]==所以用变量去接一个函数返回值(非引用)和用右值引用去接一个函数返回值有什么区别==
					- 试验了以下似乎没有区别
			- **[[$red]]==返回左值引用的情况下，既可以用变量接收返回值，也可以用引用接收返回值，有何区别？==**
				- 试验了一下如果用变量接收返回值会**触发拷贝构造函数**，相当于并没有使用引用，而是取得了一份副本
				- 左值引用则获取引用，**不会调用任何类构造器**，感觉是直接复制了"左值引用本身"(复制内存地址)
				- 无法使用右值引用接收函数返回的左值引用(编译器报错，type system直接报错)
				- 返回左值引用的函数可以**直接作为左值使用**，如``f()=20;f()++``
			- **[[$red]]==返回右值引用(配合使用std::move())的情况下，既可以用变量接收返回值，也可以用引用接收返回值，有何区别？==**
				- 根据实验，如果用变量接收返回值会触发**移动构造函数**，具体获取了哪些东西由移动构造函数的行为决定。
				- 右值引用则也是直接获取引用，**不会调用任何类构造器**
				- 无法使用左值引用接收函数返回的右值引用，同上
				- **补充**：[[$red]]==为什么一般移动构造函数的形参不加const关键字==
					- 答：因为移动构造函数一般要对源对象的成员做置空处理，因此不加const关键字
			- **[[$red]]==既然函数返回的都是右值，那么对于一个返回变量类型的函数，在实际返回时使用std::move会发生什么？==**
				- 根据实验，如果正常返回本地或临时变量会触发编译器的copy elision，则显式使用std::move会破坏此优化(根据选项，编译器可能会给出一个警告)，反之不会有明显的警告
				- 调用移动构造函数完成最后的返回赋值
				- 所以除非必须要转移所有权的情况，最好不要在返回变量的函数中返回std:move包裹的变量
			- [[$red]]==**若一个函数返回变量，但是用一个右值引用去接收会有怎样的结果**==
				- 如果函数的返回值没有被const修饰，那么可以在允许的情况下编译器会直接进行copy elision，此变量使用起来和一般变量没有区别
				- 如果不支持copy elision，则会调用拷贝构造函数，也和一般的变量没有区别
				- 如果此函数返回值被const修饰，那么编译会报错
- # 类函数的修饰问题
	- 解决此类问题的一大关键就是记住，所有成员函数都有一个隐藏的形参，就是this，**其类型是大括号前的修饰词+类type**，类似于：``Type.f(_) ...  {}`` -> ``f(... Type this, _)``
	- ## const
		- ### 在前
			- **和指针结合**
				- 若形式为：``const Type * f(_)``，那么如果要接收这个函数的返回值，变量声明也必须加const关键字，表示指向的地址内容不能改变，但是指针本身指向的地址可以改变
				- 若形式为：``Type* const f(_)``，那么接受这个函数返回值的变量可以是``Type * const p``，也可以是``Type * p``。若调用者自己的变量声明加了const，则指向的地址内容可以更改，但是指针本身指向的地址不能改变；如不加const关键字，则就是一个普通的指针
			- **和引用结合**
				- 返回常量引用，必须和函数生命保持一致，不可更改
			- **一般变量**
				- 没有作用，因为会调用拷贝构造函数或copy elision
			- [[$red]]==修饰直接返回变量而非引用和指针的函数是否是完全无效的==
				- 根据实验结果来看似乎是这样
		- ### 在后
			- const对象只能调用大括号前加了const的成员函数，非const对象都可
			- 此类修饰的函数不能修改内部成员
	- ## &&
		- 限定**只有临时对象(右值)**可以调用此方法
		- 也可以附加上const，但是没有意义，因为右值都是const的([[$red]]==?==)
	- ## &
		- 只有**左值才可调用此方法**
	- ## const &
		- 此类修饰的函数任何对象都可以调用，因为一个形如``const & x``的形参本来就可以接收任何左右值形式的实参
		- 但是由于有const修饰，不能修改内部成员
- # 临时对象生命周期问题
	- 一个临时对象和某一个变量名绑定之后生命周期就和此变量名保持一致，否则其声明语句执行完毕便被析构
	- 跨函数传递时必须要有一个变量名来接住才能完成上述生命周期延长，不能全部使用变量，如：
		- ```
		  class c {
		  	dClass&& d;
		  public:
		  	c(dClass&& d_):d(std::move(d_)){}
		  }
		  
		  c&& f(){
		  	return std::move(c());
		  }
		  
		  int main(){
		      c a(dClass()); //无效，会产生dangling pointer
		      c&& b = f(): //无效，也会产生dangling pointer
		  }
		  ```
	- 正确做法如下：
		- ```
		  class c {
		  	dClass d;
		  public:
		  	c(dClass&& d_):d(std::move(d_)){}
		  }
		  
		  c&& f(){
		  	return std::move(c()); //此函数无法改造，无论如何改写，哪怕改成局部变量，其生命周期也会在函数结束后结束
		  }
		  
		  int main(){
		      c a(dClass()); 
		  }
		  ```